{"id":3036,"date":"2016-02-23T22:29:02","date_gmt":"2016-02-23T20:29:02","guid":{"rendered":"http:\/\/stepansuvorov.com\/blog\/?p=3036"},"modified":"2016-02-23T22:32:23","modified_gmt":"2016-02-23T20:32:23","slug":"understanding-of-componentdirective-attribute-binding-types","status":"publish","type":"post","link":"https:\/\/stepansuvorov.com\/blog\/2016\/02\/understanding-of-componentdirective-attribute-binding-types\/","title":{"rendered":"Understanding of component\/directive attribute binding types"},"content":{"rendered":"<p>You probably know that directive component can have 4 different attribute-scope bindings:<\/p>\n<ul>\n<li>&#8220;<strong>@<\/strong>&#8221; &#8211; bind a local scope property to the value of DOM attribute<\/li>\n<li>&#8220;<strong>=<\/strong>&#8221; &#8211;\u00a0set up a bidirectional binding between a local scope property and an expression passed via the attribute (also for collection &#8220;<strong>=*<\/strong>&#8221; and &#8220;<strong>=?&#8221;<\/strong> if attribute is optional)<\/li>\n<li>&#8220;<strong>&lt;<\/strong>&#8221; &#8211; set up a one-way (one-directional) binding between a local scope property and an expression passed via the attribute<\/li>\n<li>&#8220;<strong>&amp;<\/strong>&#8221; &#8211;\u00a0provides a way to execute an expression in the context of the parent scope<\/li>\n<\/ul>\n<p>So I decided to uncover magic of this symbols and recreate their functionality by using attributes from the link function.<\/p>\n<p><!--more--><\/p>\n<p>Let&#8217;s take an example of a directive with all binding types:<\/p>\n<p>[javascript]<br \/>\napp.directive(&#8216;myDir&#8217;, function() {<br \/>\n  return {<br \/>\n    scope: {<br \/>\n      x: &#8216;@&#8217;,<br \/>\n      y: &#8216;=&#8217;,<br \/>\n      z: &#8216;&lt;&#8216;,<br \/>\n      f: &#8216;&amp;&#8217;<br \/>\n    },<br \/>\n    template<br \/>\n  };<br \/>\n});<br \/>\n[\/javascript]<\/p>\n<p>template could be something like this:<\/p>\n<pre>&lt;div&gt;{{x}} &lt;input ng-model=\"x\"&gt;&lt;\/div&gt;\r\n&lt;div&gt;Hello {{y}}  &lt;input ng-model=\"y\"&gt;&lt;\/div&gt;\r\n&lt;div&gt;Hello {{z}}  &lt;input ng-model=\"z\"&gt;&lt;\/div&gt;\r\n&lt;div&gt;Hello {{f()}}  &lt;input&gt;&lt;\/div&gt;<\/pre>\n<p>and integration is just:<\/p>\n<pre>&lt;my-dir x=\"Hello {{name}}\" y=\"name\" z=\"name\" f=\"getName()\"&gt;&lt;\/my-dir&gt;<\/pre>\n<p>Now we will create directive without all this scope magic\u00a0param notation,\u00a0but with the same binding functionality, just by using attributes of link function:<\/p>\n<pre>&lt;my-dir2 x=\"Hello{{name}}\" y=\"name\" z=\"name\" f=\"getName()\"&gt;&lt;\/my-dir2&gt;<\/pre>\n<p>and the definition:<\/p>\n<p>[javascript]<br \/>\napp.directive(&#8216;myDir2&#8217;, function($interpolate, $parse) {<br \/>\n  return {<br \/>\n    scope: {},<br \/>\n    template,<br \/>\n    link: function(scope, element, attrs) {}<br \/>\n  };<br \/>\n});<br \/>\n[\/javascript]<\/p>\n<p>Inside the link function we will use <strong>scope.$parent<\/strong> &#8211; link to parent scope and <strong>attrs<\/strong> &#8211; directive attributes.<\/p>\n<h2><\/h2>\n<h2>@<\/h2>\n<p>Value binding is simple, only thing that we need to do is to observe attribute and update the value:<\/p>\n<p>[javascript]<br \/>\nattrs.$observe(&#8216;x&#8217;, value =&gt; scope.x = value);<br \/>\n[\/javascript]<\/p>\n<p>to have immediate access inside link function we should probably also add:<\/p>\n<p>[javascript]<br \/>\nscope.x = $interpolate(attrs.x)(scope.$parent);<br \/>\n[\/javascript]<\/p>\n<p>we are using <a href=\"https:\/\/docs.angularjs.org\/api\/ng\/service\/$interpolate\">$interpolate<\/a> service here that will parse expression that you put into you attribute( attrs.$observe will do it by default).<\/p>\n<h2><\/h2>\n<h2>&lt;<\/h2>\n<p>One way binding. The same logic like we did for first one, only in this case we need to use <strong>$watch<\/strong> instead of $observe (now it&#8217;s property, not attribute change) and <a href=\"https:\/\/docs.angularjs.org\/api\/ng\/service\/$parse\"><strong>$parse<\/strong><\/a> instead of $interpolate(only one property not the expression):<\/p>\n<p>[javascript]<br \/>\nscope.$watch(() =&gt; $parse(attrs.z)(scope.$parent), newParentValue =&gt; scope.z = newParentValue);<br \/>\n[\/javascript]<\/p>\n<p>and again to make it accessible in link function:<\/p>\n<p>[javascript]<br \/>\nscope.z = $parse(attrs.z)(scope.$parent);<br \/>\n[\/javascript]<\/p>\n<h2><\/h2>\n<h2>=<\/h2>\n<p>Two-way binding. The most difficult one, because you need to synchronise value of the parent scope as well. Comparing to previous one you also need to store <strong>lastValue<\/strong> to understand which value has been updated: parent or directive one.<\/p>\n<p>So first lest just try to parse the attribute:<\/p>\n<p>[javascript]<br \/>\nexpressionFn = $parse(attrs.y);<br \/>\n[\/javascript]<\/p>\n<p>after we can get attribute value<\/p>\n<p>[javascript]<br \/>\nscope.y = expressionFn(scope.$parent)<br \/>\n[\/javascript]<\/p>\n<p>and store it like a lastValue:<\/p>\n<p>[javascript]<br \/>\nlastValue = scope.y;<br \/>\n[\/javascript]<\/p>\n<p>now we should setup a watcher to check whether something was changed:<\/p>\n<p>[javascript]<br \/>\nscope.$watch(() =&gt; {<br \/>\n  let parentValue = expressionFn(scope.$parent);<br \/>\n  if (angular.equals(parentValue, scope.y)) {<br \/>\n    return;<br \/>\n  }<br \/>\n});<br \/>\n[\/javascript]<\/p>\n<p>so if parentValue and scope.y are the same we finish the function, but if not we need to synchronise either parent or directive scope. How to define whine one to synchronise? We will make comparison with lastValue:<\/p>\n<p>[javascript]<br \/>\nif (!angular.equals(parentValue, lastValue)) {<br \/>\n  scope.y = parentValue;<br \/>\n}<br \/>\n[\/javascript]<\/p>\n<p>if they are not equal &#8211; we should sync directive scope property, otherwise &#8211; parent property. But how to do it? It could be done with help of special <a href=\"https:\/\/docs.angularjs.org\/api\/ng\/service\/$parse\">assign<\/a> method:<\/p>\n<p>[javascript]<br \/>\nexpressionFn.assign(scope.$parent, parentValue = scope.y);<br \/>\n[\/javascript]<\/p>\n<p>And now all together:<\/p>\n<p>[javascript]<br \/>\nlet expressionFn = $parse(attrs.y);<br \/>\nlet lastValue = scope.y = expressionFn(scope.$parent);<br \/>\nscope.$watch(() =&gt; {<br \/>\n  let parentValue = expressionFn(scope.$parent);<br \/>\n  if (angular.equals(parentValue, scope.y)) {<br \/>\n    return;<br \/>\n  }<\/p>\n<p>  if (!angular.equals(parentValue, lastValue)) {<br \/>\n    scope.y = parentValue;<br \/>\n  } else {<br \/>\n    expressionFn.assign(scope.$parent, parentValue = scope.y);<br \/>\n  }<\/p>\n<p>  return lastValue = parentValue;<br \/>\n});<br \/>\n[\/javascript]<\/p>\n<p>&nbsp;<\/p>\n<h2>&amp;<\/h2>\n<p>Execute with parent scope context. Like a piece of cake:<\/p>\n<p>[javascript]<br \/>\nscope.f = (locals) =&gt; $parse(attrs.f)(scope.$parent, locals);<br \/>\n[\/javascript]<\/p>\n<p>&nbsp;<\/p>\n<p>All these\u00a0examples were\u00a0shown only to explain you what&#8217;s\u00a0happening inside Angular and you should not use <strong>scope.$parent<\/strong> instead of attribute binding notation.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>You probably know that directive component can have 4 different attribute-scope bindings: &#8220;@&#8221; &#8211; bind a local scope property to the value of DOM attribute &#8220;=&#8221; &#8211;\u00a0set up a bidirectional binding between a local scope property and an expression passed &hellip; <a href=\"https:\/\/stepansuvorov.com\/blog\/2016\/02\/understanding-of-componentdirective-attribute-binding-types\/\">Continue reading <span class=\"meta-nav\">&rarr;<\/span><\/a><\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[4],"tags":[120,427,408],"_links":{"self":[{"href":"https:\/\/stepansuvorov.com\/blog\/wp-json\/wp\/v2\/posts\/3036"}],"collection":[{"href":"https:\/\/stepansuvorov.com\/blog\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/stepansuvorov.com\/blog\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/stepansuvorov.com\/blog\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/stepansuvorov.com\/blog\/wp-json\/wp\/v2\/comments?post=3036"}],"version-history":[{"count":5,"href":"https:\/\/stepansuvorov.com\/blog\/wp-json\/wp\/v2\/posts\/3036\/revisions"}],"predecessor-version":[{"id":3041,"href":"https:\/\/stepansuvorov.com\/blog\/wp-json\/wp\/v2\/posts\/3036\/revisions\/3041"}],"wp:attachment":[{"href":"https:\/\/stepansuvorov.com\/blog\/wp-json\/wp\/v2\/media?parent=3036"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/stepansuvorov.com\/blog\/wp-json\/wp\/v2\/categories?post=3036"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/stepansuvorov.com\/blog\/wp-json\/wp\/v2\/tags?post=3036"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}