<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>fileApi &#8211; Stepan Suvorov Blog</title>
	<atom:link href="https://stepansuvorov.com/blog/tag/fileapi/feed/" rel="self" type="application/rss+xml" />
	<link>https://stepansuvorov.com/blog</link>
	<description>Release 2.0</description>
	<lastBuildDate>Sun, 07 Sep 2014 09:09:02 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.3.1</generator>
	<item>
		<title>Пишем свой Uploader с нуля на javascript используя FileApi. Часть5. +AngularJS</title>
		<link>https://stepansuvorov.com/blog/2014/09/%d0%bf%d0%b8%d1%88%d0%b5%d0%bc-%d1%81%d0%b2%d0%be%d0%b9-uploader-%d1%81-%d0%bd%d1%83%d0%bb%d1%8f-%d0%bd%d0%b0-javascript-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d1%8f-fileapi-%d1%87%d0%b0-5/</link>
					<comments>https://stepansuvorov.com/blog/2014/09/%d0%bf%d0%b8%d1%88%d0%b5%d0%bc-%d1%81%d0%b2%d0%be%d0%b9-uploader-%d1%81-%d0%bd%d1%83%d0%bb%d1%8f-%d0%bd%d0%b0-javascript-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d1%8f-fileapi-%d1%87%d0%b0-5/#comments</comments>
		
		<dc:creator><![CDATA[Stepan]]></dc:creator>
		<pubDate>Sun, 07 Sep 2014 09:09:02 +0000</pubDate>
				<category><![CDATA[Хочу сделать мир лучше]]></category>
		<category><![CDATA[AngularJs]]></category>
		<category><![CDATA[fileApi]]></category>
		<category><![CDATA[javascript]]></category>
		<guid isPermaLink="false">http://stepansuvorov.com/blog/?p=367</guid>

					<description><![CDATA[В этой части хочу рассказать о том, как можно все эти операции с файлами завернуть в AngularJS. Рекомендую пролистать предыдущие части перед началом разбора этой: Часть 1 Часть 2 Часть 3 Часть 4 Разберем несколько ключевых поментов подключения FileApi к &#8230; <a href="https://stepansuvorov.com/blog/2014/09/%d0%bf%d0%b8%d1%88%d0%b5%d0%bc-%d1%81%d0%b2%d0%be%d0%b9-uploader-%d1%81-%d0%bd%d1%83%d0%bb%d1%8f-%d0%bd%d0%b0-javascript-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d1%8f-fileapi-%d1%87%d0%b0-5/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>В этой части хочу рассказать о том, как можно все эти операции с файлами завернуть в AngularJS.</p>
<p>Рекомендую пролистать предыдущие части перед началом разбора этой:</p>
<ul>
<li><a href="https://stepansuvorov.com/blog/2012/04/%D0%BF%D0%B8%D1%88%D0%B5%D0%BC-%D1%81%D0%B2%D0%BE%D0%B9-uploader-%D1%81-%D0%BD%D1%83%D0%BB%D1%8F-%D0%BD%D0%B0-javascript-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8F-fileapi-%D1%87%D0%B0/">Часть 1</a></li>
<li><a href="https://stepansuvorov.com/blog/2012/06/%D0%BF%D0%B8%D1%88%D0%B5%D0%BC-%D1%81%D0%B2%D0%BE%D0%B9-uploader-%D1%81-%D0%BD%D1%83%D0%BB%D1%8F-%D0%BD%D0%B0-javascript-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8F-fileapi-%D1%87%D0%B0-2/">Часть 2</a></li>
<li><a href="https://stepansuvorov.com/blog/2012/07/%D0%BF%D0%B8%D1%88%D0%B5%D0%BC-%D1%81%D0%B2%D0%BE%D0%B9-uploader-%D1%81-%D0%BD%D1%83%D0%BB%D1%8F-%D0%BD%D0%B0-javascript-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8F-fileapi-%D1%87%D0%B0-3/">Часть 3</a></li>
<li><a href="https://stepansuvorov.com/blog/2012/07/%D0%BF%D0%B8%D1%88%D0%B5%D0%BC-%D1%81%D0%B2%D0%BE%D0%B9-uploader-%D1%81-%D0%BD%D1%83%D0%BB%D1%8F-%D0%BD%D0%B0-javascript-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8F-fileapi-%D1%87%D0%B0-4/">Часть 4</a></li>
</ul>
<p><span id="more-367"></span></p>
<p>Разберем несколько ключевых поментов подключения FileApi к AngularJS:</p>
<ul>
<li>проблема ng-model и input file</li>
<li>сервис для FileApi</li>
<li>превью директива</li>
</ul>
<h2>Проблема ng-model</h2>
<p>Проблема заключается в том, что <strong>ng-model</strong> не работает с <strong>input-file</strong>, то есть он не обновит связанную модель, когда через компонент буду выбраны файлы.</p>
<p>Более подробно о проблеме можно почитать <a title="github.com/angular/angular.js/issues/1375" href="https://github.com/angular/angular.js/issues/1375">тут</a>.</p>
<p>Приходиться писать свое решение &#8211; директиву расширяющую возможности ng-model для данного элемента. Что должна делать директива? Обновлять модель по событию <strong>change</strong> (это родное браузерное событие, которое нормально отрабатывает с <strong>input-file</strong>), то есть:</p>
<p>[javascript]<br />
directive(&#8216;fileChanged&#8217;, function() {<br />
    return {<br />
      restrict: &#8216;A&#8217;,<br />
      link: function($scope, element) {</p>
<p>        element.bind(&#8216;change&#8217;, function(event) {<br />
          //&#8230;<br />
        });<br />
      }<br />
    };<br />
  });<br />
[/javascript]</p>
<p>теперь нам нужно подгрузить модель, для этого используем свойство директивы <strong>require</strong>:</p>
<p>[javascript]<br />
directive(&#8216;fileChanged&#8217;, function() {<br />
    return {<br />
      restrict: &#8216;A&#8217;,<br />
      require: &#8216;?ngModel&#8217;,<br />
      link: function($scope, element, attrs, ngModel) {<br />
        if (!ngModel) {<br />
          return;<br />
        }</p>
<p>        element.bind(&#8216;change&#8217;, function(event) {<br />
            //&#8230;<br />
        });<br />
      }<br />
    };<br />
  });<br />
[/javascript]</p>
<p>Используем &#8220;<strong>?</strong>&#8221; при загрузке, чтобы избежать ошибки(иметь возможность самим обработать) при отсутствии <strong>ng-model</strong> директивы на элементе.<br />
Зададим значение модели используя метод <strong>$setViewValue</strong> и обновим скоуп используя $scope.$apply:</p>
<p>[javascript]<br />
  directive(&#8216;fileChanged&#8217;, function() {<br />
    return {<br />
      restrict: &#8216;A&#8217;,<br />
      require: &#8216;?ngModel&#8217;,<br />
      link: function($scope, element, attrs, ngModel) {<br />
        if (!ngModel) {<br />
          return;<br />
        }</p>
<p>        element.bind(&#8216;change&#8217;, function(event) {<br />
          ngModel.$setViewValue(event.target.files[0]);<br />
          $scope.$apply();<br />
        });<br />
      }<br />
    };<br />
[/javascript]</p>
<p>И последний штрих &#8211; переопределим метод <strong>$render</strong> для <strong>ngModel</strong> на <strong>angular.noop</strong>, чтобы, когда мы обновляли значение модели, он не пытался ничего обновить во вью(мы сами контролируем этот процесс):</p>
<p>[javascript]<br />
directive(&#8216;fileChanged&#8217;, function() {<br />
    return {<br />
      restrict: &#8216;A&#8217;,<br />
      require: &#8216;?ngModel&#8217;,<br />
      link: function($scope, element, attrs, ngModel) {<br />
        if (!ngModel) {<br />
          return;<br />
        }</p>
<p>        ngModel.$render = angular.noop;</p>
<p>        element.bind(&#8216;change&#8217;, function(event) {<br />
          ngModel.$setViewValue(event.target.files[0]);<br />
          $scope.$apply();<br />
        });<br />
      }<br />
    };<br />
  });<br />
[/javascript]</p>
<p><a title="jsfiddle.net" href="http://jsfiddle.net/STEVER/gymbzmgo/">Пример полностью</a>.</p>
<h2>Сервис для FileApi</h2>
<p>Так как работаем с <strong>AngularJS</strong>, то использовать <strong>FileReader</strong> напрямую не комильфо: необходимо создать <strong>AngularJS</strong>-сервис, который будет оберткой над <strong>window.FileReader</strong>:</p>
<p>[javascript]<br />
factory(&#8216;FileReader&#8217;, function($window) {</p>
<p>    if (!$window.FileReader) {<br />
      throw new Error(&#8216;Browser does not support FileReader&#8217;);<br />
    }</p>
<p>    function readAsDataUrl(file) {<br />
      var reader = new $window.FileReader();</p>
<p>      reader.onload = function() {<br />
        //&#8230;<br />
      };</p>
<p>      reader.onerror = function() {<br />
        //&#8230;<br />
      };</p>
<p>      reader.readAsDataURL(file);</p>
<p>      return reader;<br />
    }</p>
<p>    return {<br />
      readAsDataUrl: readAsDataUrl<br />
    };<br />
}<br />
[/javascript]</p>
<p>как-то так. Обязательно через $window, а не window, как минимум для того чтобы потом удобнее было покрывать юнит-тестами.</p>
<p>Так как операции работы с файлами у нас асинхронные, то без промисов нам не обойтись &#8211; добавляем $q:</p>
<p>[javascript]<br />
factory(&#8216;FileReader&#8217;, function($q, $window) {</p>
<p>if (!$window.FileReader) {<br />
throw new Error(&#8216;Browser does not support FileReader&#8217;);<br />
}</p>
<p>function readAsDataUrl(file) {<br />
  var deferred = $q.defer(),<br />
  reader = new $window.FileReader();</p>
<p>  reader.onload = function() {<br />
    deferred.resolve(reader.result);<br />
  };</p>
<p>  reader.onerror = function() {<br />
    deferred.reject(reader.error);<br />
  };</p>
<p>  reader.readAsDataURL(file);</p>
<p>  return deferred.promise;<br />
}</p>
<p>return {<br />
  readAsDataUrl: readAsDataUrl<br />
};<br />
}<br />
[/javascript]</p>
<p><a title="gist" href="https://gist.github.com/stevermeister/b6008f4b6c7064336f85">Код</a>.</p>
<h2>Превью директива</h2>
<p>Ну и в заключение для того, чтобы использовать только что написаный сервис <strong>FileReader</strong> сделаем директиву, которая будет отображать превью загруженной картинки. HTML-представление будет выглядеть где-то так:</p>
<p>[javascript]<br />
&lt;input type=&quot;file&quot; ng-model=&quot;newImage&quot; file-changed /&gt;<br />
&lt;img file-preview=&quot;newImage&quot; /&gt;<br />
[/javascript]</p>
<ul>
<li><strong>file-changed</strong> &#8211; ранее описанная директива-фикс <strong>ng-model</strong></li>
<li><strong>file-preview</strong> &#8211; наша новая директива, которая будет отвечать за отобразжение превью при выборе файла через модель <strong>newImage</strong></li>
</ul>
<p>а код директивы:</p>
<p>[javascript]<br />
directive(&#8216;filePreview&#8217;, function (FileReader) {<br />
    return {<br />
        restrict: &#8216;A&#8217;,<br />
        scope: {<br />
            filePreview: &#8216;=&#8217;<br />
        },<br />
        link: function (scope, element, attrs) {<br />
            scope.$watch(&#8216;filePreview&#8217;, function (filePreview) {<br />
                if (filePreview &amp;&amp; Object.keys(filePreview).length !== 0) {<br />
                    FileReader.readAsDataUrl(filePreview).then(function (result) {<br />
                        element.attr(&#8216;src&#8217;, result);<br />
                    });<br />
                }<br />
            });<br />
        }<br />
    };<br />
});<br />
[/javascript]</p>
<p><strong>FileReader</strong> &#8211; раннее созданный сервис оболочка на window.FileReader с промисами<br />
<strong>filePreview: &#8216;=&#8217;</strong> &#8211; создаем изолированный скоуп и линкуем модель<br />
<strong>scope.$watch(&#8216;filePreview&#8217;</strong> &#8211; отслеживаем изменение модели<br />
<strong>FileReader.readAsDataUrl(filePreview)</strong> &#8211; считываем файл<br />
<strong>element.attr(&#8216;src&#8217;, result)</strong> &#8211; задаем картинку</p>
<p>Поиграться с примером можно <a title="jsfiddle.net" href="http://jsfiddle.net/STEVER/e8719c1j/">тут</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://stepansuvorov.com/blog/2014/09/%d0%bf%d0%b8%d1%88%d0%b5%d0%bc-%d1%81%d0%b2%d0%be%d0%b9-uploader-%d1%81-%d0%bd%d1%83%d0%bb%d1%8f-%d0%bd%d0%b0-javascript-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d1%8f-fileapi-%d1%87%d0%b0-5/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>Пишем свой Uploader с нуля на javascript используя FileApi. Часть4</title>
		<link>https://stepansuvorov.com/blog/2012/07/%d0%bf%d0%b8%d1%88%d0%b5%d0%bc-%d1%81%d0%b2%d0%be%d0%b9-uploader-%d1%81-%d0%bd%d1%83%d0%bb%d1%8f-%d0%bd%d0%b0-javascript-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d1%8f-fileapi-%d1%87%d0%b0-4/</link>
					<comments>https://stepansuvorov.com/blog/2012/07/%d0%bf%d0%b8%d1%88%d0%b5%d0%bc-%d1%81%d0%b2%d0%be%d0%b9-uploader-%d1%81-%d0%bd%d1%83%d0%bb%d1%8f-%d0%bd%d0%b0-javascript-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d1%8f-fileapi-%d1%87%d0%b0-4/#respond</comments>
		
		<dc:creator><![CDATA[Stepan]]></dc:creator>
		<pubDate>Mon, 30 Jul 2012 11:17:21 +0000</pubDate>
				<category><![CDATA[Хочу сделать мир лучше]]></category>
		<category><![CDATA[ajax]]></category>
		<category><![CDATA[fileApi]]></category>
		<category><![CDATA[javascript]]></category>
		<category><![CDATA[uploader]]></category>
		<guid isPermaLink="false">http://stepansuvorov.com/blog/?p=341</guid>

					<description><![CDATA[В частях 1, 2, 3 мы научились читать файлы с диска.Теперь попробуем разобрать процесс отправки файлов на сервер с помощью технологии ajax. В начале вспомним как работать с аяксом для передачи файла на сервер: Метод передачи будет POST Обязательно нужно &#8230; <a href="https://stepansuvorov.com/blog/2012/07/%d0%bf%d0%b8%d1%88%d0%b5%d0%bc-%d1%81%d0%b2%d0%be%d0%b9-uploader-%d1%81-%d0%bd%d1%83%d0%bb%d1%8f-%d0%bd%d0%b0-javascript-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d1%8f-fileapi-%d1%87%d0%b0-4/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>В частях <a href="https://stepansuvorov.com/blog/2012/04/%D0%BF%D0%B8%D1%88%D0%B5%D0%BC-%D1%81%D0%B2%D0%BE%D0%B9-uploader-%D1%81-%D0%BD%D1%83%D0%BB%D1%8F-%D0%BD%D0%B0-javascript-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8F-fileapi-%D1%87%D0%B0/">1</a>, <a href="https://stepansuvorov.com/blog/2012/06/%D0%BF%D0%B8%D1%88%D0%B5%D0%BC-%D1%81%D0%B2%D0%BE%D0%B9-uploader-%D1%81-%D0%BD%D1%83%D0%BB%D1%8F-%D0%BD%D0%B0-javascript-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8F-fileapi-%D1%87%D0%B0-2/">2</a>, <a href="https://stepansuvorov.com/blog/2012/07/%D0%BF%D0%B8%D1%88%D0%B5%D0%BC-%D1%81%D0%B2%D0%BE%D0%B9-uploader-%D1%81-%D0%BD%D1%83%D0%BB%D1%8F-%D0%BD%D0%B0-javascript-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8F-fileapi-%D1%87%D0%B0-3/">3</a> мы научились читать файлы с диска.Теперь попробуем разобрать процесс отправки файлов на сервер с помощью технологии ajax.</p>
<p>В начале вспомним как работать с аяксом для передачи файла на сервер:</p>
<ol>
<li>Метод передачи будет POST</li>
<li>Обязательно нужно будет указать Content-Type, а именно multipart/form-data</li>
<li>Правильно сформировать само тело сообщения</li>
</ol>
<p>Получим следующий код(по пунктам):</p>
<pre>var request = new XMLHttpRequest(); 
request.onreadystatechange = ajaxReady; 
request.open('POST', 'uploader.php', true); // (1)
request.setRequestHeader('Content-Type', contentType); // (2)
request.sendAsBinary(createTestMsg()); // (3)</pre>
<p><span id="more-341"></span>ajaxReady &#8211; это просто callback-функция, которая вызовется при ajax-ответе. Для нее пока установим простую заглушку:</p>
<pre>function ajaxReady() {
    if (request.readyState == 4 &amp;&amp; request.status == 200) {
        alert(request.responseText);
    }
}</pre>
<p>uploader.php  &#8211; тоже пока файл-заглушка на стороне сервера, следующего содержания:</p>
<pre>&lt;?php

var_dump($_POST);
var_dump($_FILES);</pre>
<p>Теперь перейдем к более важным моментам. contentType определяем следующим образом:</p>
<pre>var boundary = "AJAX-----------------------" + (new Date).getTime();
var contentType = "multipart/form-data; boundary=" + boundary;</pre>
<p>boundary &#8211; это случайная последовательность байт, которые не должны встречаться в самом файле. Вы можете придумать свой алгоритм для генерации данной последовательности, т.к. это лишь пример.</p>
<p>Ну и самое основное &#8211; формирование сообщения:</p>
<pre>function createTestMsg(){
    var fieldName = 'testfile';
    var fileName  = '4.jpg';
    var CRLF = "\r\n";

    var msg = "--" + boundary + CRLF;
    msg += 'Content-Disposition: form-data; ';
    msg += 'name="' + fieldName + '"; ';
    msg += 'filename="'+ fileName + '"' + CRLF;
    msg += 'Content-Type: application/octet-stream';
    msg += CRLF + CRLF; // marks end of the headers part
    msg += Array(9999).join(7) + CRLF;
    msg += "--" + boundary + "--" + CRLF;
    return msg;
}</pre>
<p>Array(9999).join(7) &#8211; это такой вариант генерации фэйкового контента для файла.</p>
<p>Вот тут можно посмотреть весь код: http://learn.javascript.ru/play/E1MhM, но в песочнице он работать не будет, т.к. нет файла uploader.php на строне сервера, так что в любом случае нужно копировать локально и смотреть.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://stepansuvorov.com/blog/2012/07/%d0%bf%d0%b8%d1%88%d0%b5%d0%bc-%d1%81%d0%b2%d0%be%d0%b9-uploader-%d1%81-%d0%bd%d1%83%d0%bb%d1%8f-%d0%bd%d0%b0-javascript-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d1%8f-fileapi-%d1%87%d0%b0-4/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Пишем свой Uploader с нуля на javascript используя FileApi. Часть2</title>
		<link>https://stepansuvorov.com/blog/2012/06/%d0%bf%d0%b8%d1%88%d0%b5%d0%bc-%d1%81%d0%b2%d0%be%d0%b9-uploader-%d1%81-%d0%bd%d1%83%d0%bb%d1%8f-%d0%bd%d0%b0-javascript-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d1%8f-fileapi-%d1%87%d0%b0-2/</link>
					<comments>https://stepansuvorov.com/blog/2012/06/%d0%bf%d0%b8%d1%88%d0%b5%d0%bc-%d1%81%d0%b2%d0%be%d0%b9-uploader-%d1%81-%d0%bd%d1%83%d0%bb%d1%8f-%d0%bd%d0%b0-javascript-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d1%8f-fileapi-%d1%87%d0%b0-2/#respond</comments>
		
		<dc:creator><![CDATA[Stepan]]></dc:creator>
		<pubDate>Sat, 30 Jun 2012 10:21:10 +0000</pubDate>
				<category><![CDATA[Хочу сделать мир лучше]]></category>
		<category><![CDATA[fileApi]]></category>
		<category><![CDATA[javascript]]></category>
		<category><![CDATA[uploader]]></category>
		<guid isPermaLink="false">http://stepansuvorov.com/blog/?p=255</guid>

					<description><![CDATA[Вот и созрело продолжение первой части, где мы разобрались как можно использовать родной объект FileReader для чтения файла. Давайте еще добавим прогресс чтения файла для нашего загрузчика. Для этого зададим callback метод для FileReader: reader.onprogress = updateProgress; Рассмотрим что из &#8230; <a href="https://stepansuvorov.com/blog/2012/06/%d0%bf%d0%b8%d1%88%d0%b5%d0%bc-%d1%81%d0%b2%d0%be%d0%b9-uploader-%d1%81-%d0%bd%d1%83%d0%bb%d1%8f-%d0%bd%d0%b0-javascript-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d1%8f-fileapi-%d1%87%d0%b0-2/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>Вот и созрело продолжение <a href="https://stepansuvorov.com/blog/2012/04/%D0%BF%D0%B8%D1%88%D0%B5%D0%BC-%D1%81%D0%B2%D0%BE%D0%B9-uploader-%D1%81-%D0%BD%D1%83%D0%BB%D1%8F-%D0%BD%D0%B0-javascript-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8F-fileapi-%D1%87%D0%B0/">первой части</a>, где мы разобрались как можно использовать родной объект FileReader для чтения файла.</p>
<p>Давайте еще добавим прогресс чтения файла для нашего загрузчика. Для этого зададим callback метод для FileReader:</p>
<pre>reader.onprogress = updateProgress;</pre>
<p><span id="more-255"></span></p>
<p>Рассмотрим что из себя представляет метод <strong>updateProgress</strong>:</p>
<pre>function updateProgress(event) {
    if (event.lengthComputable) {
        var progress = Math.round((event.loaded / event.total) * 100);
        document.getElementById('buffer').innerHTML = progress + '%';
    }
}</pre>
<p>Все просто. <strong>event.lengthComputable</strong> нам необходимо чтобы убедится что event &#8211; объект того события, которое мы ждем, а именно <strong>ProgressEvent</strong>.</p>
<pre>Math.round((event.loaded / event.total) * 100)</pre>
<p>Примитивная математика для вычисления процента.</p>
<pre>document.getElementById('buffer').innerHTML = progress + '%';</pre>
<p>Тут мы использовали уже имеющийся textarea элемент с id = buffer, чтобы вывести проценты туда.</p>
<p>Вот что в итоге получилось:  http://learn.javascript.ru/play/u0bbrb<br />
<em>Советую использовать большие файлы( от 100МБ) для проверки работоспособности.</em></p>
<p>!Внимание: мы рассмотрели пока прогресс загрузки файла локально, т.е. непосредственно чтения содержимого файла скриптом, но еще не саму загрузку данных на сервер.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://stepansuvorov.com/blog/2012/06/%d0%bf%d0%b8%d1%88%d0%b5%d0%bc-%d1%81%d0%b2%d0%be%d0%b9-uploader-%d1%81-%d0%bd%d1%83%d0%bb%d1%8f-%d0%bd%d0%b0-javascript-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d1%8f-fileapi-%d1%87%d0%b0-2/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Пишем свой Uploader с нуля на javascript используя FileApi. Часть1</title>
		<link>https://stepansuvorov.com/blog/2012/04/%d0%bf%d0%b8%d1%88%d0%b5%d0%bc-%d1%81%d0%b2%d0%be%d0%b9-uploader-%d1%81-%d0%bd%d1%83%d0%bb%d1%8f-%d0%bd%d0%b0-javascript-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d1%8f-fileapi-%d1%87%d0%b0/</link>
					<comments>https://stepansuvorov.com/blog/2012/04/%d0%bf%d0%b8%d1%88%d0%b5%d0%bc-%d1%81%d0%b2%d0%be%d0%b9-uploader-%d1%81-%d0%bd%d1%83%d0%bb%d1%8f-%d0%bd%d0%b0-javascript-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d1%8f-fileapi-%d1%87%d0%b0/#comments</comments>
		
		<dc:creator><![CDATA[Stepan]]></dc:creator>
		<pubDate>Sun, 29 Apr 2012 12:33:20 +0000</pubDate>
				<category><![CDATA[Хочу сделать мир лучше]]></category>
		<category><![CDATA[fileApi]]></category>
		<category><![CDATA[javascript]]></category>
		<category><![CDATA[uploader]]></category>
		<guid isPermaLink="false">http://stepansuvorov.com/blog/?p=150</guid>

					<description><![CDATA[Отметим ключевые моменты, которые нас интересуют по FileApi: &#8211; у input с атрибутом type=&#8221;file&#8221; теперь есть свойство files(массив объектов класса File) а объект класса File содержит следующие свойства: name — имя файла type — MIME тип файла size — размер &#8230; <a href="https://stepansuvorov.com/blog/2012/04/%d0%bf%d0%b8%d1%88%d0%b5%d0%bc-%d1%81%d0%b2%d0%be%d0%b9-uploader-%d1%81-%d0%bd%d1%83%d0%bb%d1%8f-%d0%bd%d0%b0-javascript-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d1%8f-fileapi-%d1%87%d0%b0/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>Отметим ключевые моменты, которые нас интересуют по FileApi:<br />
&#8211; у input с атрибутом type=&#8221;file&#8221; теперь есть свойство files(массив объектов класса File)<br />
а объект класса File содержит следующие свойства:<br />
name — имя файла<br />
type — MIME тип файла<br />
size — размер в байтах</p>
<p><span id="more-150"></span></p>
<p>Для чтения файла мы теперь можем использовать класс FileReader, который имеет следующие методы:<br />
readAsBinaryString(file) — чтение в бинарном режиме.<br />
readAsText(file[, encoding]) — чтение в текстовом режиме. Дополнительным аргументом указывается кодировка (по-умолчанию UTF-8).<br />
readAsDataURL(/forum/file) — чтение в бинарном режиме с последующей перекодировкой в Data:URL.</p>
<p>Основные моменты теории разобрали, остальное &#8211; по ходу дела.</p>
<p>Создадим простую HTMLку:</p>
<p>&lt;input type=&#8221;file&#8221; name=&#8221;file&#8221; id=&#8221;file-field&#8221;/&gt;<br />
&lt;textarea id=&#8221;buffer&#8221;&gt;&lt;/textarea&gt;</p>
<p>Для наглядности мы не будем сразу отправлять файл, а разберем пошагово процесс и загрузим содержимое файла в тег textarea:</p>
<p>Для этого повесим обработчик изменения состояния на поле ввода файла:</p>
<p>document.getElementById(&#8216;file-field&#8217;).onchange = function(){<br />
var reader = new FileReader;<br />
reader.onload = function(e){<br />
document.getElementById(&#8216;buffer&#8217;).innerHTML = e.target.result;<br />
}<br />
reader.readAsDataURL(this.files[0]);<br />
}</p>
<p>Если мы все правильно сделали, то после выбора файла его содержимое будет загружено в textarea.</p>
<p>Вот тут можно поиграться с кодом: http://learn.javascript.ru/play/esPXY</p>
<p>Подробнее можно почитать в спецификации: http://www.w3.org/TR/FileAPI/</p>
]]></content:encoded>
					
					<wfw:commentRss>https://stepansuvorov.com/blog/2012/04/%d0%bf%d0%b8%d1%88%d0%b5%d0%bc-%d1%81%d0%b2%d0%be%d0%b9-uploader-%d1%81-%d0%bd%d1%83%d0%bb%d1%8f-%d0%bd%d0%b0-javascript-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d1%8f-fileapi-%d1%87%d0%b0/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
	</channel>
</rss>
