<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Angular2 &#8211; Stepan Suvorov Blog</title>
	<atom:link href="https://stepansuvorov.com/blog/tag/angular2/feed/" rel="self" type="application/rss+xml" />
	<link>https://stepansuvorov.com/blog</link>
	<description>Release 2.0</description>
	<lastBuildDate>Thu, 23 May 2019 15:10:16 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.3.1</generator>
	<item>
		<title>Серверный рендеринг с Angular4</title>
		<link>https://stepansuvorov.com/blog/2017/03/server-side-rendering-angular4/</link>
					<comments>https://stepansuvorov.com/blog/2017/03/server-side-rendering-angular4/#comments</comments>
		
		<dc:creator><![CDATA[Stepan]]></dc:creator>
		<pubDate>Mon, 13 Mar 2017 01:17:22 +0000</pubDate>
				<category><![CDATA[Хочу сделать мир лучше]]></category>
		<category><![CDATA[Angular]]></category>
		<category><![CDATA[angular-universal]]></category>
		<category><![CDATA[Angular2]]></category>
		<category><![CDATA[angular4]]></category>
		<guid isPermaLink="false">http://stepansuvorov.com/blog/?p=3291</guid>

					<description><![CDATA[UPD: Статься обновлена 2017-04-24 Статья написана на основе перевода/переработки Server Side Rendering With Angular 4. Что нам дает серверный рендеринг? более быструю загрузку &#8220;первого экрана&#8221; поисковая оптимизация (предоставление статики для поисковых ботов) социальные превью для страничек С первых же дней &#8230; <a href="https://stepansuvorov.com/blog/2017/03/server-side-rendering-angular4/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p><strong>UPD</strong>: Статься обновлена 2017-04-24</p>
<p>Статья написана на основе перевода/переработки <a href="https://www.softwarearchitekt.at/post/2017/03/07/server-side-rendering-with-angular-4.aspx">Server Side Rendering With Angular 4</a>.</p>
<p>Что нам дает серверный рендеринг?</p>
<ul>
<li>более быструю загрузку &#8220;первого экрана&#8221;</li>
<li>поисковая оптимизация (предоставление статики для поисковых ботов)</li>
<li>социальные превью для страничек</li>
</ul>
<p>С первых же дней <del>Angular2</del> <strong>Angular</strong> включал поддержку этой опции в виде отдельного проекта <a href="https://universal.angular.io/">Angular Universal</a>. Так как <strong>серверный пререндеринг</strong> одна из ключевых киллер-фич, то начиная с <strong>Angular 4</strong> было принято решение включить доработанную версию непосредственно во фремворк.</p>
<p><span id="more-3291"></span></p>
<p>В этой статье мы описываем необходимые шаги чтобы расширить существующее Angular 4 приложение добавив серверный рендеринг. Мы будем использовать конфигурацию <a href="https://github.com/webpack/webpack">webpack</a> сгенерированную с помощью <a href="https://cli.angular.io/">Angular CLI</a>, полный пример можно найти <a href="https://github.com/stevermeister/angular-ssr">тут</a>.</p>
<h2></h2>
<h2>Достаем Webpack конфиг из Angular CLI</h2>
<p>Если вы используете Angular CLI, то вам необходимо извлечь webpack конфиг для возможной дальнейшей настройки:</p>
<pre><code>ng eject</code></pre>
<p><span style="text-decoration: underline;"><strong>Внимание</strong></span><strong>!</strong> Убедитесь в том, что вы понимаете что делает команда <strong><a href="https://github.com/angular/angular-cli/wiki/eject">ng eject</a></strong>.</p>
<p>Вариант конфигурации(<strong>webpack.config.js</strong>) предложенный CLI не включает <strong>Uglify</strong> плагина, а <strong>AOT</strong> компиляция отключена, давайте включим обе опции:</p>
<pre>[javascript]
[...]
&quot;plugins&quot;: [
	[...],
	new AotPlugin({
          [...]
	  // влючаем AOT
	  &quot;skipCodeGeneration&quot;: false
	}),

	// добавляем UglifyJsPlugin
	new webpack.optimize.UglifyJsPlugin()
]
[...]
[/javascript]</pre>
<p>В то время как <strong>AOT</strong> совсем не обязательно для серверного рендеринга, комбинируя эти опции мы можем добиться прекрасного результата в плане скорости загрузки.</p>
<h2>Необходимые пакеты</h2>
<p>Все необходимое для Angular уже подключено с помощью angular-cli, кроме пакета @angular/animations, который поставим вручную:</p>
<pre>npm install --save @angular/animations</pre>
<p>теперь подумаем о сервере.  В представленном решении используются <a href="https://nodejs.org/en/">node.js</a> вместе с <a href="http://expressjs.com/">express</a>. Поэтому мы установим express c его типами вместе с <strong>@angular/platform-server</strong>:</p>
<pre><code>npm i @angular/platform-server@next --save
npm i express @types/express --save
</code></pre>
<h2>Создание корневого модуля для серверного рендеринга</h2>
<p>Для использования серверного рендеринга нам нужен корневой модуль, который включает ServerModule. Согласно <a href="https://github.com/robwormald/ng-universal-demo/">примеру от Rob Wormald</a>, мы также включаем корневой модуль нашего основного приложения (тот что отрисовывается в браузере):</p>
<pre>[javascript]
// app.server.module.ts

import { NgModule } from '@angular/core';
import { ServerModule } from '@angular/platform-server';
import { AppModule } from './app.module';
import { AppComponent } from './app.component';

@NgModule({
  imports: [
	  ServerModule,
	  AppModule
  ],
  bootstrap: [
	  AppComponent
  ],
  providers: [ ]
})
export class AppServerModule {}
[/javascript]</pre>
<p>Далее мы должны расширить <strong>BrowserModule</strong> основного приложения указав идентификатор приложения (просто строка):</p>
<pre>[javascript]// app.module.ts

@NgModule({
    imports: [
        BrowserModule.withServerTransition({
            appId: 'demo-app'
        }),
        HttpModule,
        FormsModule,
	    [...]
    ],
    [...]
})
export class AppModule {}[/javascript]</pre>
<h2>AOT для сервера</h2>
<p>Так как <strong>AotPlugin</strong> не поддерживает серверный AOT, мы используем компилятор Angular напрямую, для этого создадим <strong>tsconfig.server.json</strong> (копию <strong>tsconfig.json</strong>) со следующими настройками <strong>angularCompilerOptions</strong>:</p>
<pre><code>"compilerOptions": {
    [...]
},
[...]
"angularCompilerOptions": {
  "genDir": "src/aot",
  "entryModule": "./src/app.server.module#AppServerModule"
}</code></pre>
<p>Настроим алиас команду в <strong>package.json</strong>:</p>
<pre><code>[...]
"scripts": {
    [...]
    "ngc:server": "ngc -p tsconfig.server.json"
}
[...]</code></pre>
<p>После вызова</p>
<pre><code>npm run ngc:server</code></pre>
<p>компилятор создаст дополнительные TypeScript файлы для проекта.</p>
<p>Внимание! До выполнения команды если вы используете структуру файлов сгенерированную Angular CLI (&lt;1.0.0-rc.1), то вам еще прийдется стереть содержимое файла <strong>./src/typings.d.ts</strong>:</p>
<p><img decoding="async" class="alignnone wp-image-3293" src="https://stepansuvorov.com/blog/wp-content/uploads/2017/03/Screen-Shot-2017-03-13-at-00.02.05.png" alt="" width="465" height="107" /></p>
<p>Иначе получите следующую ошибку: <em>Error at ./src/typings.d.ts:2:13: Subsequent variable declarations must have the same type. Variable &#8216;module&#8217; must be of type &#8216;NodeModule&#8217;, but here has type &#8216;{ id: string; }&#8217;.</em></p>
<p>Теперь можем создать главный файл для сервера &#8211; <strong>main.server.ts</strong>, в котором используем сгенерированный <strong>AppServerModuleNgFactory</strong>:</p>
<pre>[javascript]
//main.server.ts
import 'zone.js/dist/zone-node';
import { renderModuleFactory } from '@angular/platform-server';
import { enableProdMode } from '@angular/core';
import { AppServerModuleNgFactory } from './aot/src/app/app.server.module.ngfactory';
import * as express from 'express';
import * as fs from 'fs';

function ngExpressEngine() {
  return function (filePath, options, callback) {
    renderModuleFactory(AppServerModuleNgFactory, {
      document: fs.readFileSync(filePath).toString(),
      url: options.req.url
    }).then(string =&amp;amp;gt; {
        callback(null, string);
      });
  };
}

enableProdMode();

const app = express();
app.engine('html', ngExpressEngine());

app.set('view engine', 'html');
app.set('views', '.');

app.get('/', (req, res) =&amp;amp;gt; {
  res.render('index', { req });
});

app.get('/page2*', (req, res) =&amp;amp;gt; {
  res.render('index', { req });
});

app.use(express.static('.'));

app.listen(8000, () =&amp;amp;gt; console.log('listening...'));
[/javascript]</pre>
<p>Убедимся что в роутере основного модуля также есть данные стейты:</p>
<pre>[javascript]
//app.module.ts
    RouterModule.forRoot([
      { path: '', component: HomeComponent, pathMatch: 'full' },
      { path: 'page2', component: Page2Component }
    ])
[/javascript]</pre>
<h2>Webpack для серверного рендеринга</h2>
<p>Давайте создадим отдельный webpack конфиг(<strong>webpack.server.config.js</strong>) для сборки бандла серверного рендеринга, отличием будут следующие строчки:</p>
<pre><code>  // main.server.ts
  
  [...]
  target: 'node',
  [...]
  "entry": {
    "main": [
      "./src/main.server.ts"
    ]
  },</code></pre>
<p>Так как подход использует всего один бандл, то <strong>CommonsChunkPlugin</strong> можно вырезать, также можно убрать <strong>NoEmitOnErrorsPlugin</strong>.</p>
<p>Чтобы один бандл не перетирал другой, мы сделаем вывод в другой файл:</p>
<pre><code>  "output": {
    "path": path.join(process.cwd(), "dist"),
    "filename": "[name].server.bundle.js",
    "chunkFilename": "[id].server.chunk.js"
  },</code></pre>
<p>и сконфигурируем специальным образом <strong>AotPlugin</strong>:</p>
<pre><code>new AotPlugin({
  "entryModule": __dirname + "/src/app/app.server.module.ts#AppServerModule",
  "hostReplacementPaths": {
    "environments\\environment.ts": "environments\\environment.ts"
  },
  "exclude": [],
  "tsConfigPath": "./tsconfig.server.json",
  "skipCodeGeneration": false
}),</code></pre>
<h2>Итого</h2>
<p>Компилируем клиент:</p>
<pre><code>webpack</code></pre>
<p>Компилируем сервер:</p>
<pre><code>ngc -p tsconfig.server.json &amp;&amp; webpack --config webpack.server.config.js</code></pre>
<p>Запускаем</p>
<pre><code>cd dist
node main.server.bundle.js</code></pre>
<h2><strong>UPD: </strong>Кеширование ngExpressEngine</h2>
<p>Чтобы не перегружать файловую систему, мы можем кешировать результат чтения файла:</p>
<pre>[javascript]
let templateCache = {};
function ngExpressEngine() {
  return function (filePath, options, callback) {
    if (!templateCache[filePath]) {
      let file = fs.readFileSync(filePath);
      templateCache[filePath] = file.toString();
    }
    renderModuleFactory(AppServerModuleNgFactory, {
      document: fs.readFileSync(filePath).toString(),
      url: options.req.url
    }).then(string =&amp;amp;gt; {
      callback(null, string);
    });
  };
}
[/javascript]</pre>
<h2><strong>UPD2: Удобные команды для запуска</strong></h2>
<p>Мы можем прописать следующие алиас-команды в package.json:</p>
<pre><code>"scripts": {
	[...]
	"build": "npm run build:client",
	"build:client": "webpack",
	"build:server": "ngc -p tsconfig.server.json &amp;&amp; webpack --progress --config webpack.server.config.js",
	"build:all": "npm run build:client &amp;&amp; npm run build:server",
	[...]
}</code></pre>
<h2>UPD3: Проблемы с APP_BASE_HREF</h2>
<p>Для серверного модуля(app.server.module) необходимо указать <strong>APP_BASE_HREF</strong>:</p>
<pre>providers: [{provide: APP_BASE_HREF, useValue : '/' }]</pre>
<p>иначе будет следующая ошибка:</p>
<pre>Error: No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.</pre>
<h2>UPD4: 2 модуля в одной папке ломают Angular CLI</h2>
<p>И вы получаете следующую ошибку:</p>
<pre>Error locating module for declaration
 SilentError: Multiple module files found:</pre>
<p>Чтобы починить пришлось во всех местах переименовать <strong>app.server.module.ts</strong> в <strong>app.server-module.ts</strong></p>
]]></content:encoded>
					
					<wfw:commentRss>https://stepansuvorov.com/blog/2017/03/server-side-rendering-angular4/feed/</wfw:commentRss>
			<slash:comments>25</slash:comments>
		
		
			</item>
		<item>
		<title>Концептуальный разбор маршрутизатора Angular2 с примерами</title>
		<link>https://stepansuvorov.com/blog/2017/02/%d0%ba%d0%be%d0%bd%d1%86%d0%b5%d0%bf%d1%82%d1%83%d0%b0%d0%bb%d1%8c%d0%bd%d1%8b%d0%b9-%d1%80%d0%b0%d0%b7%d0%b1%d0%be%d1%80-%d0%bc%d0%b0%d1%80%d1%88%d1%80%d1%83%d1%82%d0%b8%d0%b7%d0%b0%d1%82%d0%be%d1%80/</link>
					<comments>https://stepansuvorov.com/blog/2017/02/%d0%ba%d0%be%d0%bd%d1%86%d0%b5%d0%bf%d1%82%d1%83%d0%b0%d0%bb%d1%8c%d0%bd%d1%8b%d0%b9-%d1%80%d0%b0%d0%b7%d0%b1%d0%be%d1%80-%d0%bc%d0%b0%d1%80%d1%88%d1%80%d1%83%d1%82%d0%b8%d0%b7%d0%b0%d1%82%d0%be%d1%80/#comments</comments>
		
		<dc:creator><![CDATA[Stepan]]></dc:creator>
		<pubDate>Sat, 18 Feb 2017 09:32:18 +0000</pubDate>
				<category><![CDATA[Хочу сделать мир лучше]]></category>
		<category><![CDATA[Angular2]]></category>
		<category><![CDATA[angular2-router]]></category>
		<guid isPermaLink="false">http://stepansuvorov.com/blog/?p=3217</guid>

					<description><![CDATA[подключение и базовая настройка use hash стейты (states) специальные директивы роутера параметры стейта параметры запроса(query params) статические параметры стейта перенаправление на другой стейт события (events) хуки (guards) резолв асинхронных данных вложенные стейты (nested states) множественные вью (multiple views) ленивая загрузка (lazy loading) Подключение и базовая &#8230; <a href="https://stepansuvorov.com/blog/2017/02/%d0%ba%d0%be%d0%bd%d1%86%d0%b5%d0%bf%d1%82%d1%83%d0%b0%d0%bb%d1%8c%d0%bd%d1%8b%d0%b9-%d1%80%d0%b0%d0%b7%d0%b1%d0%be%d1%80-%d0%bc%d0%b0%d1%80%d1%88%d1%80%d1%83%d1%82%d0%b8%d0%b7%d0%b0%d1%82%d0%be%d1%80/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<ul>
<li>подключение и базовая настройка
<ul>
<li>use hash</li>
</ul>
</li>
<li>стейты (states)</li>
<li>специальные директивы роутера</li>
<li>параметры стейта</li>
<li>параметры запроса(query params)</li>
<li>статические параметры стейта</li>
<li>перенаправление на другой стейт</li>
<li>события (events)</li>
<li>хуки (guards)</li>
<li>резолв асинхронных данных</li>
<li>вложенные стейты (nested states)</li>
<li>множественные вью (multiple views)</li>
<li>ленивая загрузка (lazy loading)</li>
</ul>
<p><span id="more-3217"></span></p>
<h2>Подключение и базовая настройка</h2>
<p>Для использования маршрутизатора нам необходимо в первую очередь импортировать его модуль:</p>
<pre>import { RouterModule } from '@angular/router'</pre>
<p>и прописать в зависимостях:</p>
<p>[javascript]<br />
imports: [</p>
<p>RouterModule,</p>
<p>],<br />
[/javascript]</p>
<p>После чего мы можем настроить состояния(стейты). Добавим корневой стейт:</p>
<p>[javascript]<br />
const routes = [<br />
  {path: &#8221;, component: HomeComponent},<br />
];<br />
[/javascript]</p>
<p>синтаксис, как вы видите, довольно простой. Нам достаточно указать путь и компонент, который будет отображаться по этому пути. Можем таким же способом добавить еще один стейт:</p>
<p>[javascript]<br />
const routes = [<br />
  {path: &#8221;, component: HomeComponent},<br />
  { path: &#8216;user&#8217;, component: UsersComponent},<br />
];<br />
[/javascript]</p>
<p>Теперь, чтобы подключить описание стейтов к модулю роутера сделаем:</p>
<p>[javascript]<br />
imports: [</p>
<p>RouterModule.forRoot(routes),</p>
<p>],<br />
[/javascript]</p>
<p>По умолчанию используются HTML5 пути, но если мы хотим переключить на хеш, то нам нужно указать дополнительный параметр:</p>
<p>[javascript]<br />
imports: [</p>
<p>RouterModule.forRoot(routes, {useHash: true}),</p>
<p>],<br />
[/javascript]</p>
<h2>Специальные директивы роутера</h2>
<p><a href="https://angular.io/docs/ts/latest/api/router/index/RouterOutlet-directive.html">RouterOutlet</a> &#8211; для задание места вывода представления:</p>
<p>[html]<br />
&lt;router-outlet&gt;&lt;/router-outlet&gt;;<br />
[/html]</p>
<p><a href="https://angular.io/docs/ts/latest/api/router/index/RouterLink-directive.html">RouterLink</a> &#8211; хелпер для удобного вывода ссылки:</p>
<p>[html]<br />
&lt;a routerLink=&quot;user&quot;&gt;User&lt;/a&gt;<br />
[/html]</p>
<p><a href="https://angular.io/docs/ts/latest/api/router/index/RouterLinkActive-directive.html">RouterLinkActive</a> &#8211; для выделения(задания специального css класса) активных(указывающих на текущий стейт) ссылок:</p>
<p>[html]<br />
&lt;a routerLink=&quot;user&quot; routerLinkActive=&quot;active-class&quot;&gt;User&lt;/a&gt;<br />
[/html]</p>
<p>также можно задавать параметр</p>
<p>[html]<br />
[routerLinkActiveOptions]=&quot;{exact: true}&quot;<br />
[/html]</p>
<h2></h2>
<h2>Параметры стейта</h2>
<p>Определяем параметр в настройках стейта:</p>
<p>[javascript]<br />
 { path: &#8216;user/:userId&#8217;, component: UsersComponent},<br />
[/javascript]</p>
<p>Получаем этот параметр с помощью специального сервиса <strong>ActivatedRoute</strong>:</p>
<p>[javascript]<br />
constructor(private route: ActivatedRoute) {<br />
  this.route.params.subscribe(params =&gt; console.log(params.userId));<br />
}<br />
[/javascript]</p>
<p>также можно подписаться на конкретный параметр с помощью метода <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/pluck.md">pluck</a>:</p>
<p>[javascript]<br />
constructor(private route: ActivatedRoute) {<br />
  this.route.params.pluck(&#8216;userId&#8217;).subscribe(userId =&gt; console.log(userId));<br />
}<br />
[/javascript]</p>
<h2>Параметры запроса(query params)</h2>
<p>Кроме параметров стейта, можем также добавлять в url произвольное количество параметров запроса:</p>
<p>[html]<br />
&lt;a routerLink=&quot;search&quot; [queryParams]=&quot;{ city: &#8216;Amsterdam&#8217; }&quot;&gt;Filter by Amsterdam&lt;/a&gt;<br />
[/html]</p>
<p>либо если изменяем стейт с помощью метода navigate:</p>
<p>[javascript]<br />
this.router.navigate([&#8216;/search&#8217;], { queryParams: { city:&#8217;Amsterdam&#8217; } });<br />
[/javascript]</p>
<p>Чтобы получить параметры стейта подписываемся на queryParams свойство:</p>
<p>[javascript]<br />
constructor(private route: ActivatedRoute) {<br />
  this.route.queryParams.subscribe(params =&gt; console.log(params.city));<br />
}<br />
[/javascript]</p>
<h2></h2>
<h2>Cтатические параметры стейта</h2>
<p>Стейт также можно дополнять статическими параметрами:</p>
<p>[javascript]<br />
  { path: &#8216;user&#8217;, component: UsersComponent,<br />
    data: {userName: &#8216;John&#8217;}},<br />
[/javascript]</p>
<p>И получить доступ через сервис <strong>ActivatedRoute</strong>:</p>
<p>[javascript]<br />
constructor(private route: ActivatedRoute) {<br />
  this.route.data.subscribe(console.log);<br />
}<br />
[/javascript]</p>
<h2>Перенаправление на другой стейт</h2>
<p>Перенаправление может быть либо <strong>автоматическим</strong> (постоянный редирект) либо <strong>условным</strong> (по какому-то действию).</p>
<p>Чтобы сделать автоматический редирект в настройках стейта мы прописываем свойство <strong>redirectTo</strong>, где указываем стейт, на который хотим перенаправить:</p>
<p>[javascript]<br />
const routes = [<br />
  { path: &#8221;, redirectTo: &#8216;dashboard&#8217;, pathMatch: &#8216;full&#8217; },<br />
  { path: &#8216;dashboard&#8217;, component: DashboardComponent },<br />
];<br />
[/javascript]</p>
<p>обратите также внимание, что в случае <strong>path: &#8221;</strong> мы должны указать строгую стратегию разбора URL &#8211; <strong>pathMatch: &#8216;full&#8217;</strong>.</p>
<p>Для условного перенаправления мы используем методы <strong>router.navigate()</strong> и <strong>router.navigateByUrl()</strong>:</p>
<p>[javascript]<br />
router.navigate([&#8216;users&#8217;, userId]);<br />
router.navigateByUrl(`users/${userId}`);<br />
[/javascript]</p>
<p>&#8211; отличие только в том, что в первом случае вы подаете как параметр набор команд, а во втором строку URL.</p>
<h2>Cобытия роутера</h2>
<p>Мы можем подписываться не только на данные, но и на события происходящие в роутере, в этом нам поможет сервис <strong>Router</strong>:</p>
<p>[javascript]<br />
  constructor(router: Router) {<br />
    router.events.subscribe((event: Event) =&gt; {<br />
      if (event instanceof NavigationStart) {<br />
        //&#8230;<br />
      }<br />
    });<br />
  }<br />
[/javascript]</p>
<p>кроме события <strong>NavigationStart</strong> мы также можем слушать:</p>
<ul>
<li><strong>NavigationEnd</strong></li>
<li><strong>NavigationCancel</strong></li>
<li><strong>NavigationError</strong></li>
<li><strong>RoutesRecognized</strong></li>
</ul>
<h2></h2>
<h2>Хуки (guards)</h2>
<p>На ряду с событиями в роутере есть <strong>хуки</strong>(<strong>guards</strong>), которые в отличие от событий выполняются <strong>ДО</strong> действия и в данном случае мы можем вклиниться в поток выполнения, и если нужно остановить выполнение события.</p>
<p>Существуют следующие хуки:</p>
<ul>
<li>
<p class="comments-section"><strong>CanActivate</strong> &#8211; определяет возможность загрузки стейта</p>
</li>
<li>
<p class="comments-section"><strong>CanActivateChild</strong> &#8211; аналогично предыдущего только для вложенного стейта</p>
</li>
<li>
<p class="comments-section"><strong>CanDeactivate</strong> &#8211; запускается при смене стейта, хорошим примером будет подтверждение не сохраненных данных перед уходом со страницы:</p>
<pre><code>CanDeactivate(){
      return window.confirm("You have unsaved changes. Still want to leave?");
}
</code></pre>
</li>
<li>
<p class="comments-section"><strong>CanLoad</strong> &#8211; определяет может ли стейт быть загружен асинхронно</p>
</li>
<li>
<p class="comments-section"><strong>Resolve</strong> &#8211; для резолвинга данных до загрузки стейта (см. отдельный пункт о резолвинге данных)</p>
</li>
</ul>
<p>Для реализации хука нам нужно 2 момента: определить его в стейте:</p>
<p>[javascript]<br />
{ path: &#8216;user&#8217;, component: UsersComponent, canActivate: AuthService},<br />
[/javascript]</p>
<p>и создать сам хук-сервис, который будет реализовывать соотвествующий интерфейс:</p>
<p>[javascript]<br />
import {CanActivate} from &#8216;@angular/router&#8217;;<br />
export class AuthService implements CanActivate{<br />
  canActivate(): boolean {<br />
    return true;<br />
  }<br />
}<br />
[/javascript]</p>
<p>В методе <strong>canActivate</strong> мы можем возвращать как просто булевое значение, так и асинхронные <strong>Promise</strong> и <strong>Observable</strong>.</p>
<h2></h2>
<h2>Резолвинг асинхронных данных</h2>
<p>Для подгрузки асинхронных данных до загрузки стейта также используется хук &#8211; <strong>Resolve</strong>:</p>
<p>[javascript]<br />
{ path: &#8216;user&#8217;, component: UsersComponent, resolve:{ user: UserDataResolveService }},<br />
[/javascript]</p>
<p>теперь создадим резолв-сервис:</p>
<p>[javascript]<br />
import { Resolve } from &#8216;@angular/router&#8217;;<br />
export class UserDataResolveService implements Resolve&lt;any&gt; {<br />
  resolve() {<br />
    return { name: &#8216;Bob&#8217; };<br />
  }<br />
}<br />
[/javascript]</p>
<p>и можно будет подписаться на эти данные, также как и на статические:</p>
<p>[javascript]<br />
  constructor(route: ActivatedRoute) {<br />
    route.data.subscribe(data =&gt; {<br />
      console.log(data.user);<br />
    });<br />
  }<br />
[/javascript]</p>
<h2></h2>
<h2>Вложенные стейты (nested states)</h2>
<p>Для задание вложенных/дочерних стейтов мы используем свойство children, в котором определяем массив:</p>
<p>[javascript]<br />
  { path: &#8216;user&#8217;, children: [<br />
      {path: &#8221;, component: UserProfileComponent},<br />
      {path: &#8216;settings&#8217;, component: UserSettingsComponent}<br />
    ]},<br />
[/javascript]</p>
<p>синтаксис вложенных стейтов идентичен основным. Вложенные стейты также могут иметь свои вложенные.</p>
<h2>Множественные вью (multiple views)</h2>
<p>Роутер ангуляра поддерживает множественные вью, то есть наличие нескольких именованных <strong>RouterOutlet</strong> компонентов:</p>
<p>[html]<br />
&lt;router-outlet&gt;&lt;/router-outlet&gt;<br />
&lt;router-outlet name=&quot;popup&quot;&gt;&lt;/router-outlet&gt;<br />
[/html]</p>
<p>Неименованный &#8211; основной. Теперь для настройки прописываем специальное свойство <strong>outlet</strong>:</p>
<p>[javascript]<br />
  { path: &#8216;user&#8217;, component: HomeComponent },<br />
  { path: &#8216;user&#8217;, component: UsersComponent, outlet: &#8216;popup&#8217;},<br />
[/javascript]</p>
<p>Ссылка routerLink будет выглядеть для такого случая следующим образом:</p>
<p>[html]<br />
&lt;a [routerLink]=&quot;[{ outlets: { primary: &#8216;user&#8217;, popup: &#8216;user&#8217; } }]&quot;&gt;&lt;/a&gt;<br />
[/html]</p>
<p>а если мы хотим деактивировать второстепенный аутлет:</p>
<p>[html]<br />
&lt;a [routerLink]=&quot;[{ outlets: { popup: null } }]&quot;&gt;Close user&lt;/a&gt;<br />
[/html]</p>
<h2></h2>
<h2>Ленивая загрузка (lazy loading)</h2>
<p>Роутер также дает нам возможность организовать отложенную(ленивую) загрузку модулей. Для этого нам необходимо прописать в стейт специальное свойство <strong>loadChildren</strong> и указать в нем путь и имя модуля, который собираемся загрузить:</p>
<p>[javascript]<br />
{ path: &#8216;lazy&#8217;, loadChildren: &#8216;./lazy/lazy.module#LazyModule&#8217; }<br />
[/javascript]</p>
<p>и инициализировать <strong>RouterModule</strong> внутри <strong>LazyModule</strong>:</p>
<p>[javascript]<br />
const routes: Routes = [<br />
  { path: &#8221;, component: AdminComponent }<br />
];</p>
<p>@NgModule({<br />
  imports: [<br />
    CommonModule,<br />
    RouterModule.forChild(routes)<br />
  ],<br />
  declarations: [AdminComponent]<br />
})<br />
export class LazyModule { }<br />
[/javascript]</p>
<p>мы можем определить сколько захотим состояний для <strong>LazyModule</strong>, но я для простоты определил один, который загрузит компонент <strong>AdminComponent</strong>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://stepansuvorov.com/blog/2017/02/%d0%ba%d0%be%d0%bd%d1%86%d0%b5%d0%bf%d1%82%d1%83%d0%b0%d0%bb%d1%8c%d0%bd%d1%8b%d0%b9-%d1%80%d0%b0%d0%b7%d0%b1%d0%be%d1%80-%d0%bc%d0%b0%d1%80%d1%88%d1%80%d1%83%d1%82%d0%b8%d0%b7%d0%b0%d1%82%d0%be%d1%80/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Angular2: Changing default component properties.</title>
		<link>https://stepansuvorov.com/blog/2017/01/angular2-changing-default-component-properties/</link>
					<comments>https://stepansuvorov.com/blog/2017/01/angular2-changing-default-component-properties/#comments</comments>
		
		<dc:creator><![CDATA[Stepan]]></dc:creator>
		<pubDate>Sat, 28 Jan 2017 12:05:15 +0000</pubDate>
				<category><![CDATA[Хочу сделать мир лучше]]></category>
		<category><![CDATA[Angular2]]></category>
		<category><![CDATA[angular2-component]]></category>
		<category><![CDATA[angular2-decorators]]></category>
		<guid isPermaLink="false">http://stepansuvorov.com/blog/?p=3258</guid>

					<description><![CDATA[Attention! Please keep in mind that this post is not manual, it&#8217;s research that helps you to understand Angular better and don&#8217;t try to apply code examples in your enterprise applications. If you look into all the angular exports you &#8230; <a href="https://stepansuvorov.com/blog/2017/01/angular2-changing-default-component-properties/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p><em><strong>Attention!</strong> Please keep in mind that this post<span style="text-decoration: underline;"> is not manual</span>, it&#8217;s research that helps you to understand Angular better and don&#8217;t try to apply code examples in your enterprise applications.</em></p>
<p><span id="more-3258"></span></p>
<p>If you look into all the angular exports you could find specific super private(double low dash) property __core_private__ :</p>
<p>[javascript]import { __core_private__ } from &#8216;@angular/core&#8217;;[/javascript]</p>
<p>it provides us access to a method makeDecorator that is kind of internal factory to make all the decorators, so to create new decorator you just need to do:</p>
<p>[javascript]__core_private__.makeDecorator(&#8216;myNewDecorator&#8217;, {});[/javascript]</p>
<p>so if you wanna create your own Component decorator it&#8217;s just:</p>
<p>[javascript]const MyComponent = __core_private__.makeDecorator(&#8216;MyComponent&#8217;, {});[/javascript]</p>
<p>there is also <span style="text-decoration: underline;">3rd paramete</span>r that allows us to make <strong>inheritance</strong> from another decorator, so let&#8217;s use existing <strong>Component decorator</strong>:</p>
<p>[javascript]<br />
const MyComponent = __core_private__.makeDecorator(&#8216;MyComponent&#8217;, {}, Component);<br />
[/javascript]</p>
<p>we need to set required properties(it will not work without them):</p>
<p>[javascript]<br />
const MyComponent = __core_private__.makeDecorator(&#8216;myComponent&#8217;,{<br />
selector: undefined,<br />
template: &#8221;,<br />
styleUrls: undefined},Component))<br />
[/javascript]</p>
<p>and you could also extend some extra, for example <strong>switch off encapsulation</strong>:</p>
<p>[javascript]<br />
const MyComponent = __core_private__.makeDecorator(&#8216;myComponent&#8217;,{<br />
selector: undefined,<br />
template: &#8221;,<br />
styleUrls: undefined<br />
encapsulation: ViewEncapsulation.None<br />
},Component))<br />
[/javascript]</p>
<p>All code for module(mycomponent.ts):</p>
<p>[javascript]<br />
import {__core_private__, Component, ViewEncapsulation} from &#8216;@angular/core&#8217;;</p>
<p>let MyComponent = __core_private__.makeDecorator(&#8216;myComponent&#8217;, {<br />
 selector: undefined,<br />
 template: &#8221;,<br />
 styleUrls: undefined,<br />
 encapsulation: ViewEncapsulation.None},<br />
 Component);</p>
<p>export {MyComponent as Component}<br />
[/javascript]</p>
<p><span style="font-weight: 300;">that can be use instead of core Component:</span></p>
<p>[javascript]<br />
import {Component} from &#8216;./mycomponent&#8217;;<br />
[/javascript]</p>
<p>&nbsp;</p>
]]></content:encoded>
					
					<wfw:commentRss>https://stepansuvorov.com/blog/2017/01/angular2-changing-default-component-properties/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Что нового в Angular 2.3 и Angular 2.4</title>
		<link>https://stepansuvorov.com/blog/2017/01/new-in-angular-2-3-2-4/</link>
					<comments>https://stepansuvorov.com/blog/2017/01/new-in-angular-2-3-2-4/#respond</comments>
		
		<dc:creator><![CDATA[Stepan]]></dc:creator>
		<pubDate>Sun, 22 Jan 2017 08:37:30 +0000</pubDate>
				<category><![CDATA[Хочу сделать мир лучше]]></category>
		<category><![CDATA[Angular2]]></category>
		<guid isPermaLink="false">http://stepansuvorov.com/blog/?p=3239</guid>

					<description><![CDATA[Пройдемся по основным моментам: Наследование компонентов Сервис языка шаблонов Ангулар ( Angular Language Service ) Улучшеный стек zone.js Доступ к версии Ангуляра Обновление rxjs Наследование компонентов То, что мы все ждем еще с первой версии Ангуляра, наконец-то пришло, и нам &#8230; <a href="https://stepansuvorov.com/blog/2017/01/new-in-angular-2-3-2-4/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>Пройдемся по основным моментам:</p>
<ul class="postList">
<li id="650a" class="graf graf--li graf-after--p">Наследование компонентов</li>
<li id="9c8d" class="graf graf--li graf-after--li">Сервис языка шаблонов Ангулар ( <a href="https://github.com/angular/angular/tree/master/modules/%40angular/language-service">Angular Language Service </a>)</li>
<li class="graf graf--li graf-after--li">Улучшеный стек zone.js</li>
<li class="graf graf--li graf-after--li">Доступ к версии Ангуляра</li>
<li class="graf graf--li graf-after--li">Обновление rxjs</li>
</ul>
<p><span id="more-3239"></span></p>
<h2>Наследование компонентов</h2>
<p>То, что мы все ждем еще с первой версии Ангуляра, наконец-то пришло, и нам не нужно придумывать своих велосипедов:</p>
<p>[javascript]<br />
@Component({<br />
  selector: &#8216;person&#8217;,<br />
  template: `<br />
&lt;h4&gt;Person: {{name}}&lt;/h4&gt;</p>
<p>`<br />
})<br />
export class Person {<br />
  @Input() name: string;<br />
}</p>
<p>@Component({<br />
  selector: &#8217;employee&#8217;,<br />
  template: `<br />
&lt;h4&gt;Employee: {{name}}, id: {{id}}&lt;/h4&gt;</p>
<p>`<br />
})<br />
export class Employee extends Person {<br />
  @Input() id: string;<br />
}</p>
<p>&lt;div&gt;<br />
  &lt;person name=&quot;John&quot;&gt;&lt;/person&gt;<br />
  &lt;employee name=&quot;Tom&quot; id=&quot;45231&quot;&gt;&lt;/employee&gt;<br />
&lt;/div&gt;</p>
<p>[/javascript]</p>
<p>То есть мы удобно можем расширить существующий компонент, при этом переопределив селектор и шаблон.</p>
<p>* привер взят из <a href="https://medium.com/@gerard.sans/angular-2-new-features-in-angular-2-3-f2e73f16a09e#.4ueyfyfi4">Angular 2 — New features in Angular 2.3</a></p>
<h2>Сервис языка шаблонов Ангулар</h2>
<p>Сервис поможет средствам разработки(IDE) лучше понимать шаблоны, делать проверку и подсвечивать ошибки. Сервис будет редактор-независимый, но при этом приоритет отдается VS Code (<a href="https://github.com/angular/vscode-ng-language-service">plugin</a>). По факту это только проба пера и полноценную доработанную версию можно ждать в Angular 4.</p>
<h2>Улучшеный стек zone.js</h2>
<p>Стек трейс для ошибок стал более четкий</p>
<p><img decoding="async" fetchpriority="high" class="alignnone wp-image-3240" src="https://stepansuvorov.com/blog/wp-content/uploads/2017/01/Screen-Shot-2017-01-22-at-10.19.09.png" alt="" width="417" height="370" /></p>
<h2>Доступ к версии Ангуляра</h2>
<p>Версию Ангуляра мы можем получить как импортировав специальную константу <strong>VERSION</strong>:</p>
<p>[javascript]<br />
import {VERSION} from &#8216;@angular/core&#8217;;<br />
console.log(VERSION);<br />
[/javascript]</p>
<p>так и из атрибута корневого элемента:</p>
<p><img decoding="async" class="alignnone size-full wp-image-3241" src="https://stepansuvorov.com/blog/wp-content/uploads/2017/01/Screen-Shot-2017-01-22-at-10.24.13.png" alt="" width="320" height="56" /></p>
<h2>Обновление rxjs</h2>
<p>Теперь(начиная с версии <strong>2.4</strong>) под капотом будет стабильная <strong>5.0.1</strong>. До этого долгое время оставалась <strong>5.0.0-beta.12</strong>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://stepansuvorov.com/blog/2017/01/new-in-angular-2-3-2-4/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Angular2: Opaque токены и мультипровайдеры</title>
		<link>https://stepansuvorov.com/blog/2017/01/angular2-opaque-%d1%82%d0%be%d0%ba%d0%b5%d0%bd%d1%8b-%d0%b8-%d0%bc%d1%83%d0%bb%d1%8c%d1%82%d0%b8%d0%bf%d1%80%d0%be%d0%b2%d0%b0%d0%b9%d0%b4%d0%b5%d1%80%d1%8b/</link>
					<comments>https://stepansuvorov.com/blog/2017/01/angular2-opaque-%d1%82%d0%be%d0%ba%d0%b5%d0%bd%d1%8b-%d0%b8-%d0%bc%d1%83%d0%bb%d1%8c%d1%82%d0%b8%d0%bf%d1%80%d0%be%d0%b2%d0%b0%d0%b9%d0%b4%d0%b5%d1%80%d1%8b/#comments</comments>
		
		<dc:creator><![CDATA[Stepan]]></dc:creator>
		<pubDate>Sat, 21 Jan 2017 18:35:12 +0000</pubDate>
				<category><![CDATA[Хочу сделать мир лучше]]></category>
		<category><![CDATA[Angular2]]></category>
		<category><![CDATA[angular2-providers]]></category>
		<category><![CDATA[opaque-token]]></category>
		<guid isPermaLink="false">http://stepansuvorov.com/blog/?p=3232</guid>

					<description><![CDATA[При определении провайдеров рано или поздно у всех у нас возникает вопрос &#8220;А что если будет 2 провайдера с одним и тем же именем?&#8221; &#8211; Ну тут все довольно просто: последний определенный перезатрет все определенные до него. Но что если &#8230; <a href="https://stepansuvorov.com/blog/2017/01/angular2-opaque-%d1%82%d0%be%d0%ba%d0%b5%d0%bd%d1%8b-%d0%b8-%d0%bc%d1%83%d0%bb%d1%8c%d1%82%d0%b8%d0%bf%d1%80%d0%be%d0%b2%d0%b0%d0%b9%d0%b4%d0%b5%d1%80%d1%8b/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>При определении провайдеров рано или поздно у всех у нас возникает вопрос &#8220;<em>А что если будет 2 провайдера с одним и тем же именем?</em>&#8221; &#8211; Ну тут все довольно просто: последний определенный перезатрет все определенные до него.</p>
<p>Но что если вы подключаете сторонний модуль, а в нем уже определен провайдер с таким же именем? Очевидно, что вы его перезатрете своим. Как избежать этого?</p>
<p><span id="more-3232"></span></p>
<h2>Opaque токен</h2>
<p>На помощь нам спешит <strong>opaque токен</strong>, который выглядит немного как костыль архитектуры. Чтобы избежать коллизии, мы заворачиваем имя нашего сервиса в объект с помощью класса <strong>OpaqueToken</strong>:</p>
<p>[javascript]<br />
const MY_HTTP_TOKEN: OpaqueToken = new OpaqueToken(&#8216;Http&#8217;);<br />
[/javascript]</p>
<p>Если мы посмотрим на исходный код этого класса, то увидим <a href="https://github.com/angular/angular/blob/d169c2434e3b5cd5991e38ffd8904e0919f11788/modules/%40angular/core/src/di/injection_token.ts#L35">всего одну строчку реализации</a>:</p>
<p>[javascript]<br />
export class OpaqueToken {<br />
  constructor(protected _desc: string) {}</p>
<p>  toString(): string { return `Token ${this._desc}`; }<br />
}<br />
[/javascript]</p>
<p>То есть мы просто  заворачиваем наше название в объект, который в случае чего его вернет.</p>
<p>Что это дает? Какое бы мы <s>дурацкое</s> уникальное имя не придумали для своего провайдера, все равно есть вероятность, что кто-то придумает что-то подобное. А вот при создании нового объекта мы всегда гарантируем что он будет уникальный. И теперь коллизии нам не страшны &#8211; можем спокойно внедрять нашу сущность:</p>
<p>[javascript]<br />
constructor(@Inject(MY_HTTP_TOKEN) private myHttp){<br />
[/javascript]</p>
<h2></h2>
<p>&nbsp;</p>
<h2>Мультипровайдеры</h2>
<p>Но представим другую ситуацию: вам внезапно захотелось запихнуть в провайдер несколько классов. Зачем? Ну вот захотелось. И чтобы для каждого класса отрабатывал механизм внедрения зависимости и получал сущность. И, да, разработчики предусмотрели и такой случай. Для этого вам нужно использовать мультипровайдеры, а именно специальное свойство <strong>multi</strong> при определении провайдера:</p>
<p>[javascript]<br />
  providers: [<br />
  { provide: &#8216;SuperProvider&#8217;, useClass: class A {}, multi: true },<br />
  { provide: &#8216;SuperProvider&#8217;, useClass: class B {}, multi: true}]<br />
[/javascript]</p>
<p>И теперь можем инжектить два-в-одном:</p>
<p>[javascript]<br />
 constructor(@Inject(&#8216;SuperProvider&#8217;) private testInjection) {<br />
[/javascript]</p>
<p>и получить в testInjection массив из 2х сущностей: экземпляров класса A и B.</p>
<p>Так, еще раз &#8211; зачем это нужно? Если вы пишете библиотеку/плагин и хотите сделать его расширяемым для разработчиков, которые будут подключать ваше решение в свои приложения, думаю это именно то, что вам нужно. Именно так реализованы 2 сервиса хранящие валидаторы в ангуляре, а именно <strong>NG_VALIDATORS</strong> и <strong>NG_ASYNC_VALIDATORS</strong>, что позволяет вам добавить свои валидаторы в стандартную коллекцию:</p>
<p>[javascript]<br />
{ provide: NG_VALIDATORS, useValue: (formControl) =&gt; {}, multi: true }<br />
[/javascript]</p>
<p>По прежнему остается вопрос: зачем использовать задание провайдеров через строки, если это может привести к коллизии? Оставим его на совести разработчиков Angular 2.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://stepansuvorov.com/blog/2017/01/angular2-opaque-%d1%82%d0%be%d0%ba%d0%b5%d0%bd%d1%8b-%d0%b8-%d0%bc%d1%83%d0%bb%d1%8c%d1%82%d0%b8%d0%bf%d1%80%d0%be%d0%b2%d0%b0%d0%b9%d0%b4%d0%b5%d1%80%d1%8b/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>Angular2: Синхронная асинхронность MockBackend</title>
		<link>https://stepansuvorov.com/blog/2017/01/angular2-%d1%81%d0%b8%d0%bd%d1%85%d1%80%d0%be%d0%bd%d0%bd%d0%b0%d1%8f-%d0%b0%d1%81%d0%b8%d0%bd%d1%85%d1%80%d0%be%d0%bd%d0%bd%d0%be%d1%81%d1%82%d1%8c-mockbackend/</link>
					<comments>https://stepansuvorov.com/blog/2017/01/angular2-%d1%81%d0%b8%d0%bd%d1%85%d1%80%d0%be%d0%bd%d0%bd%d0%b0%d1%8f-%d0%b0%d1%81%d0%b8%d0%bd%d1%85%d1%80%d0%be%d0%bd%d0%bd%d0%be%d1%81%d1%82%d1%8c-mockbackend/#respond</comments>
		
		<dc:creator><![CDATA[Stepan]]></dc:creator>
		<pubDate>Fri, 20 Jan 2017 08:57:46 +0000</pubDate>
				<category><![CDATA[Хочу сделать мир лучше]]></category>
		<category><![CDATA[Angular2]]></category>
		<category><![CDATA[MockBackend]]></category>
		<guid isPermaLink="false">http://stepansuvorov.com/blog/?p=3230</guid>

					<description><![CDATA[Решил сделать заметку по не очевидному моменту юнит-тестирования Angular2, а именно: когда вы мокаете Http сервис, заменяя XHRBackend на MockBackend: [javascript] TestBed.configureTestingModule({ imports: [HttpModule], providers: [{provide: XHRBackend, useClass: MockBackend}] }); [/javascript] а потом с помощью mockBackend подменяете ответ от сервера: [javascript] &#8230; <a href="https://stepansuvorov.com/blog/2017/01/angular2-%d1%81%d0%b8%d0%bd%d1%85%d1%80%d0%be%d0%bd%d0%bd%d0%b0%d1%8f-%d0%b0%d1%81%d0%b8%d0%bd%d1%85%d1%80%d0%be%d0%bd%d0%bd%d0%be%d1%81%d1%82%d1%8c-mockbackend/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>Решил сделать заметку по не очевидному моменту юнит-тестирования <strong>Angular2</strong>, а именно: когда вы мокаете <strong>Http</strong> сервис, заменяя <strong>XHRBackend</strong> на <strong>MockBackend</strong>:</p>
<p>[javascript]<br />
  TestBed.configureTestingModule({<br />
      imports: [HttpModule],<br />
      providers: [{provide: XHRBackend, useClass: MockBackend}]<br />
  });<br />
[/javascript]</p>
<p>а потом с помощью <strong>mockBackend</strong> подменяете ответ от сервера:</p>
<p>[javascript]<br />
    mockBackend.connections.subscribe((connection: MockConnection) =&gt; {<br />
      connection.mockRespond(new Response(new ResponseOptions({body: JSON.stringify(mockUser)})));<br />
    })<br />
[/javascript]</p>
<p><strong>subscribe</strong> на http Observable <span style="text-decoration: underline;">становится внезапно <strong>синхронным</strong></span>:</p>
<p>[javascript]<br />
console.log(1);<br />
this._http.get(&#8216;/&#8217;).subscribe((data) =&gt; {<br />
      console.log(2);<br />
    });<br />
console.log(3);<br />
[/javascript]</p>
<p>соотвественно выведет: 1 2 3.</p>
<p>Подробно вопрсос освещен на <a href="http://stackoverflow.com/questions/41273244/angular-testing-http-with-mockbackend-is-async-really-required">стеке</a>.</p>
<p>&nbsp;</p>
]]></content:encoded>
					
					<wfw:commentRss>https://stepansuvorov.com/blog/2017/01/angular2-%d1%81%d0%b8%d0%bd%d1%85%d1%80%d0%be%d0%bd%d0%bd%d0%b0%d1%8f-%d0%b0%d1%81%d0%b8%d0%bd%d1%85%d1%80%d0%be%d0%bd%d0%bd%d0%be%d1%81%d1%82%d1%8c-mockbackend/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Angular2: Что такое AoT?</title>
		<link>https://stepansuvorov.com/blog/2017/01/angular2-aot/</link>
					<comments>https://stepansuvorov.com/blog/2017/01/angular2-aot/#respond</comments>
		
		<dc:creator><![CDATA[Stepan]]></dc:creator>
		<pubDate>Wed, 18 Jan 2017 20:54:08 +0000</pubDate>
				<category><![CDATA[Хочу сделать мир лучше]]></category>
		<category><![CDATA[Angular2]]></category>
		<category><![CDATA[aot]]></category>
		<guid isPermaLink="false">http://stepansuvorov.com/blog/?p=3221</guid>

					<description><![CDATA[Что это такое? AOT или Ahead-of-Time &#8211; вариант компиляции приложения(альтернатива JIT или Just-in-time), которая выполняется один раз при сборке приложения. JIT выполняется каждый раз при запуске приложения в браузере. &#160; Зачем это делать? компиляция шаблонов до сборки (выявление ошибок при сборке) &#8230; <a href="https://stepansuvorov.com/blog/2017/01/angular2-aot/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<h2>Что это такое?</h2>
<p><strong>AOT</strong> или <strong>Ahead-of-Time</strong> &#8211; вариант компиляции приложения(альтернатива <strong>JIT</strong> или <strong>Just-in-time</strong>), которая выполняется один раз при сборке приложения. <strong>JIT</strong> выполняется каждый раз при запуске приложения в браузере.</p>
<p><span id="more-3221"></span></p>
<p>&nbsp;</p>
<h2>Зачем это делать?</h2>
<ul>
<li>компиляция шаблонов до сборки (выявление ошибок при сборке)</li>
<li>более быстрый запуск приложения</li>
<li>скомпилированный файл получается меньше (не нужно включать компилятор в сборку)</li>
<li>вопрос безопасности (меньше вероятность внедрения)</li>
</ul>
<p>&nbsp;</p>
<h2>Больше цифр</h2>
<p><img decoding="async" loading="lazy" class="alignnone wp-image-3223" src="https://stepansuvorov.com/blog/wp-content/uploads/2017/01/Screen-Shot-2017-01-18-at-22.19.02.png" alt="" width="443" height="248" /></p>
<p>* взято из презентации <a href="https://www.youtube.com/watch?v=_VnV7R4Ncwc">Optimizing Angular 2 Apps</a> от Martin Probst.</p>
<h2>Живые цифры (сам проверил 2017-01-18)</h2>
<p>angular-cli стартер без AOT(<strong>ng build</strong>):</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-3224" src="https://stepansuvorov.com/blog/wp-content/uploads/2017/01/Screen-Shot-2017-01-18-at-22.32.32.png" alt="" width="538" height="118" /></p>
<p>angular-cli стартер c AOT (<strong>ng build &#8211;aot</strong>):</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-3225" src="https://stepansuvorov.com/blog/wp-content/uploads/2017/01/Screen-Shot-2017-01-18-at-22.33.50.png" alt="" width="512" height="126" /></p>
<h2>Больше информации?</h2>
<ul>
<li><a href="https://angular.io/docs/ts/latest/cookbook/aot-compiler.html">Официальная дока</a></li>
<li>Презентация <a href="https://www.youtube.com/watch?v=kW9cJsvcsGo">The Angular 2 Compiler</a> от Tobias Bosch</li>
<li><a href="https://www.npmjs.com/package/source-map-explorer">source-map-explorer</a> &#8211; полезный инструмент для анализа бандла</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content:encoded>
					
					<wfw:commentRss>https://stepansuvorov.com/blog/2017/01/angular2-aot/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Angular2: Possible parameters for @HostBinding and @HostListener decorators</title>
		<link>https://stepansuvorov.com/blog/2017/01/angular2-possible-parameters-for-hostbinding-and-hostlistener-decorators/</link>
					<comments>https://stepansuvorov.com/blog/2017/01/angular2-possible-parameters-for-hostbinding-and-hostlistener-decorators/#respond</comments>
		
		<dc:creator><![CDATA[Stepan]]></dc:creator>
		<pubDate>Sat, 14 Jan 2017 21:16:53 +0000</pubDate>
				<category><![CDATA[Хочу сделать мир лучше]]></category>
		<category><![CDATA[Angular2]]></category>
		<category><![CDATA[HostBinding]]></category>
		<category><![CDATA[HostListener]]></category>
		<guid isPermaLink="false">http://stepansuvorov.com/blog/?p=3214</guid>

					<description><![CDATA[@HostBinding(?) propertyName: references a property of the host with the propertyName name. attr.attributeName: references an attribute of the host with the attributeName name. The initial value is set to the associated directive property. Setting a value in the property updates &#8230; <a href="https://stepansuvorov.com/blog/2017/01/angular2-possible-parameters-for-hostbinding-and-hostlistener-decorators/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<h2>@HostBinding(?)</h2>
<ul>
<li id="a726" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">propertyName</strong>: references a property of the host with the <strong class="markup--strong markup--li-strong">propertyName</strong> name.</li>
<li id="fe6e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">attr.attributeName</strong>: references an attribute of the host with the <strong class="markup--strong markup--li-strong">attributeName</strong> name. The initial value is set to the associated directive property. Setting a value in the property updates the attribute on the corresponding HTML element. Using the null value at this level removes the attribute on the HTML element.</li>
<li id="5508" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">style.styleName</strong>: links a directive property to a style of the HTML element.</li>
<li id="3732" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">class.className</strong>: links a directive property to a class name of the HTML element. If the value is true, the class is added otherwise removed.</li>
</ul>
<h2>@HostListener(?)</h2>
<ul class="postList">
<li id="3894" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">eventName</strong>: the name of the event to register a method callback on.</li>
</ul>
<p><span id="more-3214"></span></p>
<p>Example for all the cases:</p>
<p>[javascript]<br />
@Directive({<br />
  selector: &#8216;mydir&#8217;<br />
})<br />
export class SomeDirective {<br />
  @HostBinding(&#8216;value&#8217;) value:string;<br />
  @HostBinding(&#8216;attr.role&#8217;) role:string;<br />
  @HostBinding(&#8216;style.width.px&#8217;) width:number;<br />
  @HostBinding(&#8216;class.someClass&#8217;) condition:boolean;<br />
  @HostListener(&#8216;input&#8217;) onInput() {<br />
    console.log(&#8216;on input in directive&#8217;);<br />
  }<br />
}<br />
[/javascript]</p>
<p>&nbsp;</p>
]]></content:encoded>
					
					<wfw:commentRss>https://stepansuvorov.com/blog/2017/01/angular2-possible-parameters-for-hostbinding-and-hostlistener-decorators/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Шпаргалка по синтаксису шаблонов Angular2</title>
		<link>https://stepansuvorov.com/blog/2017/01/%d1%88%d0%bf%d0%b0%d1%80%d0%b3%d0%b0%d0%bb%d0%ba%d0%b0-%d0%bf%d0%be-%d1%81%d0%b8%d0%bd%d1%82%d0%b0%d0%ba%d1%81%d0%b8%d1%81%d1%83-%d1%88%d0%b0%d0%b1%d0%bb%d0%be%d0%bd%d0%be%d0%b2-angular2/</link>
					<comments>https://stepansuvorov.com/blog/2017/01/%d1%88%d0%bf%d0%b0%d1%80%d0%b3%d0%b0%d0%bb%d0%ba%d0%b0-%d0%bf%d0%be-%d1%81%d0%b8%d0%bd%d1%82%d0%b0%d0%ba%d1%81%d0%b8%d1%81%d1%83-%d1%88%d0%b0%d0%b1%d0%bb%d0%be%d0%bd%d0%be%d0%b2-angular2/#respond</comments>
		
		<dc:creator><![CDATA[Stepan]]></dc:creator>
		<pubDate>Sat, 07 Jan 2017 20:26:30 +0000</pubDate>
				<category><![CDATA[Хочу сделать мир лучше]]></category>
		<category><![CDATA[Angular2]]></category>
		<category><![CDATA[cheatsheet]]></category>
		<category><![CDATA[templates]]></category>
		<guid isPermaLink="false">http://stepansuvorov.com/blog/?p=3197</guid>

					<description><![CDATA[взято с официальной документации, переведено/переработано. &#60;input [value]=&#8221;firstName&#8221;&#62; задание свойства value &#60;div [attr.role]=&#8221;myAriaRole&#8221;&#62; задание атрибута role. &#60;div [class.extra-sparkle]=&#8221;isDelightful&#8221;&#62; Выставляет класс extra-sparkle по условию isDelightful &#60;div [style.width.px]=&#8221;mySize&#8221;&#62; задает значение width в пикселях. &#60;button (click)=&#8221;readRainbow($event)&#8221;&#62; Привязывает обраобтчик клика readRainbow &#60;p&#62;Hello {{ponyName}}&#60;/p&#62; &#60;div title=&#8221;Hello {{ponyName}}&#8220;&#62; Подставляет значение выражения &#60;my-cmp [(title)]=&#8221;name&#8221;&#62; Двойное связывание, альтернатива: &#8230; <a href="https://stepansuvorov.com/blog/2017/01/%d1%88%d0%bf%d0%b0%d1%80%d0%b3%d0%b0%d0%bb%d0%ba%d0%b0-%d0%bf%d0%be-%d1%81%d0%b8%d0%bd%d1%82%d0%b0%d0%ba%d1%81%d0%b8%d1%81%d1%83-%d1%88%d0%b0%d0%b1%d0%bb%d0%be%d0%bd%d0%be%d0%b2-angular2/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>взято с <a href="https://angular.io/docs/ts/latest/guide/cheatsheet.html">официальной документации</a>, переведено/переработано.</p>
<table class="ng-scope">
<tbody>
<tr>
<th></th>
<th></th>
</tr>
<tr class="ng-scope">
<td>&lt;input <strong>[value]</strong>=&#8221;firstName&#8221;&gt;</td>
<td>задание свойства <strong>value</strong></td>
</tr>
<tr class="ng-scope">
<td>&lt;div <strong>[attr.role]</strong>=&#8221;myAriaRole&#8221;&gt;</td>
<td>задание атрибута <strong>role</strong>.</td>
</tr>
<tr class="ng-scope">
<td>&lt;div <strong>[class.extra-sparkle]</strong>=&#8221;isDelightful&#8221;&gt;</td>
<td>Выставляет класс <strong>extra-sparkle</strong> по условию <strong>isDelightful</strong></td>
</tr>
<tr class="ng-scope">
<td>&lt;div <strong>[style.width.px]</strong>=&#8221;mySize&#8221;&gt;</td>
<td>задает значение <strong>width</strong> в пикселях.</td>
</tr>
<tr class="ng-scope">
<td>&lt;button <strong>(click)</strong>=&#8221;readRainbow($event)&#8221;&gt;</td>
<td>Привязывает обраобтчик клика <strong>readRainbow</strong></td>
</tr>
<tr class="ng-scope">
<td>&lt;p&gt;Hello <strong>{{ponyName}}</strong>&lt;/p&gt;<br />
&lt;div title=&#8221;Hello <strong>{{ponyName}}</strong>&#8220;&gt;</td>
<td>Подставляет значение выражения</td>
</tr>
<tr class="ng-scope">
<td>&lt;my-cmp <strong>[(title)]</strong>=&#8221;name&#8221;&gt;</td>
<td>Двойное связывание, альтернатива: &lt;my-cmp [title]=&#8221;name&#8221; (titleChange)=&#8221;name=$event&#8221;&gt;</td>
</tr>
<tr class="ng-scope">
<td>&lt;video <strong>#movieplayer</strong> &#8230;&gt;<br />
&lt;button <strong>(click)</strong>=&#8221;movieplayer.play()&#8221;&gt;<br />
&lt;/video&gt;</td>
<td>Создает локальную переменную <strong>movieplayer</strong>, которая является ссылкой на элемент <strong>video</strong></td>
</tr>
<tr class="ng-scope">
<td>&lt;p <strong>*myUnless</strong>=&#8221;myExpression&#8221;&gt;&#8230;&lt;/p&gt;</td>
<td>Символ <strong>*</strong> превращает текущий элмент во втроенный шаблон: :&lt;template [myUnless]=&#8221;myExpression&#8221;&gt;&lt;p&gt;&#8230;&lt;/p&gt;&lt;/template&gt;</td>
</tr>
<tr class="ng-scope">
<td>&lt;p&gt;Card No.: <strong>{{cardNumber | myCardNumberFormatter}}</strong>&lt;/p&gt;</td>
<td>Применение <strong>myCardNumberFormatter</strong> пайпа.</td>
</tr>
<tr class="ng-scope">
<td>&lt;p&gt;Employer: <strong>{{employer?.companyName}}</strong>&lt;/p&gt;</td>
<td>Указание не обязательного поля с помощью оператора &#8220;<strong>?</strong>&#8220;</td>
</tr>
</tbody>
</table>
]]></content:encoded>
					
					<wfw:commentRss>https://stepansuvorov.com/blog/2017/01/%d1%88%d0%bf%d0%b0%d1%80%d0%b3%d0%b0%d0%bb%d0%ba%d0%b0-%d0%bf%d0%be-%d1%81%d0%b8%d0%bd%d1%82%d0%b0%d0%ba%d1%81%d0%b8%d1%81%d1%83-%d1%88%d0%b0%d0%b1%d0%bb%d0%be%d0%bd%d0%be%d0%b2-angular2/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Как запустить Angular2 ChangeDetection вручную</title>
		<link>https://stepansuvorov.com/blog/2016/12/%d0%ba%d0%b0%d0%ba-%d0%b7%d0%b0%d0%bf%d1%83%d1%81%d1%82%d0%b8%d1%82%d1%8c-angular2-changedetection-%d0%b2%d1%80%d1%83%d1%87%d0%bd%d1%83%d1%8e/</link>
					<comments>https://stepansuvorov.com/blog/2016/12/%d0%ba%d0%b0%d0%ba-%d0%b7%d0%b0%d0%bf%d1%83%d1%81%d1%82%d0%b8%d1%82%d1%8c-angular2-changedetection-%d0%b2%d1%80%d1%83%d1%87%d0%bd%d1%83%d1%8e/#respond</comments>
		
		<dc:creator><![CDATA[Stepan]]></dc:creator>
		<pubDate>Tue, 06 Dec 2016 21:40:52 +0000</pubDate>
				<category><![CDATA[Хочу сделать мир лучше]]></category>
		<category><![CDATA[Angular2]]></category>
		<category><![CDATA[ChangeDetection]]></category>
		<guid isPermaLink="false">http://stepansuvorov.com/blog/?p=3175</guid>

					<description><![CDATA[Небольшая заметка по мотивам ответа на stackoverflow. Внедрив следующие сервисы в компонент ApplicationRef, NgZone, ChangeDetectorRef, мы можем добиться следующего: ApplicationRef.tick() &#8211; то есть запуск changeDetection на корневом элементе, то есть соотвественно запуск на всех элементах дерева(аналог  $rootScope.$digest() ) NgZone.run(callback) &#8211; тоже самое что и предыдущий &#8230; <a href="https://stepansuvorov.com/blog/2016/12/%d0%ba%d0%b0%d0%ba-%d0%b7%d0%b0%d0%bf%d1%83%d1%81%d1%82%d0%b8%d1%82%d1%8c-angular2-changedetection-%d0%b2%d1%80%d1%83%d1%87%d0%bd%d1%83%d1%8e/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>Небольшая заметка по мотивам <a href="http://stackoverflow.com/a/34829089/274500">ответа на stackoverflow</a>.</p>
<p>Внедрив следующие сервисы в компонент</p>
<p><strong>ApplicationRef</strong>, <strong>NgZone</strong>, <strong>ChangeDetectorRef</strong>,</p>
<p>мы можем добиться следующего:</p>
<ul>
<li><a href="https://angular.io/docs/ts/latest/api/core/index/ApplicationRef-class.html#!#tick-anchor">ApplicationRef.tick()</a> &#8211; то есть запуск <strong>changeDetection</strong> на корневом элементе, то есть соотвественно запуск на всех элементах дерева(аналог  <strong>$rootScope.$digest() </strong>)</li>
<li><a href="https://angular.io/docs/ts/latest/api/core/index/NgZone-class.html#!#run-anchor">NgZone.run(callback)</a> &#8211; тоже самое что и предыдущий вариант, только с выполнением колбэка (аналог <strong>$rootScope.$apply(callback)</strong> )</li>
<li><a href="https://angular.io/docs/ts/latest/api/core/index/ChangeDetectorRef-class.html#!#detectChanges-anchor">ChangeDetectorRef.detectChanges()</a> &#8211; запуск механизма обнаружения изменений только на текущем элементе ( аналог<strong> $scope.$digest()</strong> )</li>
</ul>
<p><span id="more-3175"></span></p>
<p>Ну и так, бонусом: отсоединение и присоединение обратно детектора изменений конкретного компонента:</p>
<p>[javascript]<br />
constructor(private cd: ChangeDetectorRef) {<br />
    this.cd.detach();<br />
    setInterval(() =&gt; {<br />
      this.cd.detectChanges();<br />
    }, 5000);<br />
  }<br />
[/javascript]</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content:encoded>
					
					<wfw:commentRss>https://stepansuvorov.com/blog/2016/12/%d0%ba%d0%b0%d0%ba-%d0%b7%d0%b0%d0%bf%d1%83%d1%81%d1%82%d0%b8%d1%82%d1%8c-angular2-changedetection-%d0%b2%d1%80%d1%83%d1%87%d0%bd%d1%83%d1%8e/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
