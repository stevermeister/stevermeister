<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>$digest &#8211; Stepan Suvorov Blog</title>
	<atom:link href="https://stepansuvorov.com/blog/tag/digest/feed/" rel="self" type="application/rss+xml" />
	<link>https://stepansuvorov.com/blog</link>
	<description>Release 2.0</description>
	<lastBuildDate>Wed, 28 Oct 2015 07:03:41 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.3.1</generator>
	<item>
		<title>Keep an eye on AngularJS perfomance with ng-stats</title>
		<link>https://stepansuvorov.com/blog/2015/10/keep-an-eye-on-angularjs-perfomance-with-ng-stats/</link>
					<comments>https://stepansuvorov.com/blog/2015/10/keep-an-eye-on-angularjs-perfomance-with-ng-stats/#respond</comments>
		
		<dc:creator><![CDATA[Stepan]]></dc:creator>
		<pubDate>Thu, 22 Oct 2015 18:54:09 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[Рекомендую]]></category>
		<category><![CDATA[$digest]]></category>
		<category><![CDATA[$watch]]></category>
		<category><![CDATA[AngularJs]]></category>
		<category><![CDATA[ng-stats]]></category>
		<category><![CDATA[snippet]]></category>
		<category><![CDATA[tool]]></category>
		<guid isPermaLink="false">http://stepansuvorov.com/blog/?p=2877</guid>

					<description><![CDATA[ng-stats is nice utility from Kent C. Dodds that allows you to see statistics for your page&#8217;s angular digest/watches. to install just put this code into your bookmarks: [javascript] javascript: (function() {var a = document.createElement(&#34;script&#34;);a.src = &#34;https://rawgithub.com/kentcdodds/ng-stats/master/dist/ng-stats.js&#34;;a.onload=function(){window.showAngularStats()};document.head.appendChild(a)})(); [/javascript]]]></description>
										<content:encoded><![CDATA[<p><a href="https://github.com/kentcdodds/ng-stats"><img decoding="async" class="alignnone size-full wp-image-2878" src="https://stepansuvorov.com/blog/wp-content/uploads/2015/10/Screenshot-2015-10-22-20.00.42.png" alt="ng-stats" width="213" height="186" /></a></p>
<p><a href="https://github.com/kentcdodds/ng-stats">ng-stats</a> is nice utility from <a href="https://github.com/kentcdodds">Kent C. Dodds</a> that allows you to see statistics for your page&#8217;s angular digest/watches.</p>
<p>to install just put this code into your bookmarks:</p>
<p>[javascript]<br />
javascript: (function() {var a = document.createElement(&quot;script&quot;);a.src = &quot;https://rawgithub.com/kentcdodds/ng-stats/master/dist/ng-stats.js&quot;;a.onload=function(){window.showAngularStats()};document.head.appendChild(a)})();<br />
[/javascript]</p>
]]></content:encoded>
					
					<wfw:commentRss>https://stepansuvorov.com/blog/2015/10/keep-an-eye-on-angularjs-perfomance-with-ng-stats/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Создаем упрощенный цикл Angular Digest</title>
		<link>https://stepansuvorov.com/blog/2015/03/simple-angular-digest/</link>
					<comments>https://stepansuvorov.com/blog/2015/03/simple-angular-digest/#respond</comments>
		
		<dc:creator><![CDATA[Stepan]]></dc:creator>
		<pubDate>Sun, 01 Mar 2015 17:26:20 +0000</pubDate>
				<category><![CDATA[Хочу сделать мир лучше]]></category>
		<category><![CDATA[$digest]]></category>
		<category><![CDATA[AngularJs]]></category>
		<category><![CDATA[javascript]]></category>
		<guid isPermaLink="false">http://stepansuvorov.com/blog/?p=2235</guid>

					<description><![CDATA[Я уже создавал упрощенную модель внедрения зависимостей AngularJS, теперь решил тоже проделать с циклом дайджета. Именно всемогущий дайджет и решает работу всех вотчеров, а так как двойное связывание строится на вотчерах, то он вообще все решает. Место действия $rootScope, а еще точнее &#8230; <a href="https://stepansuvorov.com/blog/2015/03/simple-angular-digest/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p><img decoding="async" fetchpriority="high" class="alignnone wp-image-2393" src="https://stepansuvorov.com/blog/wp-content/uploads/2015/03/digest.png" alt="картинка взята с ng-book" width="227" height="238" /></p>
<p>Я уже создавал <a href="https://stepansuvorov.com/blog/2014/03/%D0%B2%D1%8B%D0%B4%D0%B8%D1%80%D0%B0%D0%B5%D0%BC-%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D1%83-di-%D0%B8%D0%B7-angularjs/">упрощенную модель внедрения зависимостей AngularJS</a>, теперь решил тоже проделать с циклом дайджета.</p>
<p><span id="more-2235"></span></p>
<p>Именно всемогущий дайджет и решает работу всех вотчеров, а так как двойное связывание строится на вотчерах, то он вообще все решает.</p>
<p>Место действия <code>$rootScope</code>, а еще точнее &#8211;  <code>Scope.prototype</code>. Именно там определяется метод <code>$digest</code>.</p>
<h2>Постановка задачи</h2>
<p>Попробуем сформулировать условие задачи: нам необходимо реализовать такой метод <code>digest</code>, который проверит все наблюдаемые переменные и, если значение было изменено, вызовет колбэк.</p>
<p>Дополнительно нам нужно договориться как мы будем определять/задавать этим самые наблюдаемые переменные. Допустим мы сделаем это тоже через метод <code>watch</code>, как это делает <strong>AngularJS</strong>.</p>
<p>Итого имеем:</p>
<p>[javascript]<br />
var rootScope = function () {};<br />
rootScope.prototype = {<br />
  watch: function (watchExp, listener) {},<br />
  digest: function () {}<br />
}<br />
[/javascript]</p>
<p>(я специально не использую $ перед <code>rootScope</code>, <code>watch</code> и <code>digest</code>, чтобы как-то разделить реализации AngularJS и мою)</p>
<p>Ну и соотвественно вариант использования подразумевает быть таким:</p>
<p>[javascript]<br />
var scope = new rootScope();<br />
    scope.x = 5;<br />
    scope.watch(&#8216;x&#8217;, function(newValue, oldValue){ alert(&#8216;changed:&#8217; + oldValue + &#8216;-&gt;&#8217; + newValue) });<br />
    scope.x = 10;<br />
    scope.digest();<br />
[/javascript]</p>
<p>этот код должен вывести алерт со значениями.</p>
<h2>Реализация</h2>
<p>Займемся методом <code>watch</code>. У него четкое назначение &#8211; создавать &#8220;вотчеры&#8221; &#8211; то есть объекты, которые будут в себе хранить информацию о наблюдаемом объекте.</p>
<p>Чтобы хранить где-то эти вотчеры создадим специальное свойство-массив у объекта <code>rootScope</code>:</p>
<p>[javascript]<br />
var rootScope = function () {<br />
  this.watchers = [];<br />
};<br />
[/javascript]</p>
<p>Теперь при каждом вызове метода <code>watch</code> можем записывать новый объект в этот массив:</p>
<p>[javascript]<br />
&#8230;<br />
watch: function (watchExp, listener) {<br />
            var watcher = {<br />
                watchExp : watchExp,<br />
                listener : listener || function() {},<br />
                lastValue: this[watchExp],<br />
            };<br />
            this.watchers.push(watcher);<br />
        },<br />
&#8230;<br />
[/javascript]</p>
<p>C методом <code>watch</code> разобрались, теперь перейдем к методу <code>digest</code>. По идее этот метод должен пробегать по всем вотчерам и смотреть не изменились ли они. А если изменились &#8211; вызывать их обработчики:</p>
<p>[javascript]<br />
digest: function () {<br />
            var scope = this;<br />
            this.watchers.forEach(function(watcher){<br />
                if(watcher.lastValue !== scope[watcher.watchExp]){<br />
                    watcher.listener.call(scope, scope[watcher.watchExp], watcher.lastValue);<br />
                }<br />
            });<br />
        }<br />
[/javascript]</p>
<p>и еще, в случае когда значение обновилось, нам нужно сохранить новое значение:</p>
<p>[javascript]<br />
digest: function () {<br />
            var scope = this;<br />
            this.watchers.forEach(function(watcher){<br />
                if(watcher.lastValue !== scope[watcher.watchExp]){<br />
                    watcher.listener.call(scope, scope[watcher.watchExp], watcher.lastValue);<br />
                    watcher.lastValue = scope[watcher.watchExp];<br />
                }<br />
            });<br />
        }<br />
[/javascript]</p>
<p>Как будто бы все. Но нет &#8211; мы забыли еще добавить механизм &#8220;грязной проверки&#8221;, которая позволяет убедиться в том, что мы &#8220;ни о ком не забыли&#8221;. Уточнение: при выполнении обработчиков вотчеров мы могли изменить значения других наблюдаемых объектов, то есть снова их сделали &#8220;грязными&#8221;.</p>
<p>Чтобы это учесть введем специальную переменную &#8211; индикатор статуса <code>dirty</code>:</p>
<p>[javascript]<br />
digest: function () {<br />
  var scope = this,<br />
      dirty = false;<br />
  this.watchers.forEach(function(watcher){<br />
    if(watcher.lastValue !== scope[watcher.watchExp]){<br />
      watcher.listener.call(scope, scope[watcher.watchExp], watcher.lastValue);<br />
      watcher.lastValue = scope[watcher.watchExp];<br />
      dirty = true;<br />
   }<br />
 });<br />
 return dirty;<br />
}<br />
[/javascript]</p>
<p>теперь завернем всю нашу логику в метод <code>digestOnce</code> и будем выполнять его до тех пор, пока не &#8220;почистим&#8221; все вотчеры:</p>
<p>[javascript]<br />
digest: function () {<br />
        var dirty;<br />
        do {<br />
            dirty = digestOnce(this);<br />
        } while (dirty);</p>
<p>        function digestOnce(scope) {<br />
            var dirty = false;<br />
            scope.watchers.forEach(function (watcher) {<br />
                if (watcher.lastValue !== scope[watcher.watchExp]) {<br />
                    watcher.listener.call(scope, scope[watcher.watchExp], watcher.lastValue);<br />
                    watcher.lastValue = scope[watcher.watchExp];<br />
                    dirty = true;<br />
                }<br />
            });<br />
            return dirty;<br />
        }<br />
    }<br />
[/javascript]</p>
<p>Ну вот и все: упрощенная модель дайджеста готова. С кодом можно поиграться <a title="jsfiddle" href="http://jsfiddle.net/STEVER/y1hgjjt4/">тут</a>.</p>
<h2>Бонус</h2>
<p>Во избежание зацикливания дайджеста( например: в случае циклических зависимостей) мы можем ограничить количество проходов c помощью специальной переменной. В <strong>AngularJS</strong> эту переменную назвали <code>TTL</code> (вероятно от аббревиатуры &#8220;time to live&#8221;):</p>
<p>[javascript]<br />
digest: function () {<br />
        var dirty,<br />
            ttl = 10;<br />
        do {<br />
            dirty = digestOnce(this);<br />
            if (dirty &amp;&amp; !(ttl&#8211;)) {<br />
               throw &quot;10 digest iterations reached&quot;;<br />
            }<br />
        } while (dirty);<br />
&#8230;<br />
[/javascript]</p>
<p>Также в <strong>AngularJS</strong> есть возможность снятия вотчера путем выполнения функции возвращаемой из метода <code>$watch</code>. Реализуем эту функциональность сохранив синтаксис AngularJS. Для этого нам нужно удалить наш вотчер из массива вотчеров:</p>
<p>[javascript]<br />
watch: function (watchExp, listener) {<br />
  var watcher = {<br />
        watchExp: watchExp,<br />
        listener: listener,<br />
        lastValue: this[watchExp],<br />
  }, scope = this;<br />
  this.watchers.push(watcher);<br />
  return function unwatch(){<br />
    scope.watchers.splice(scope.watchers.indexOf(watcher), 1);<br />
  };<br />
}<br />
[/javascript]</p>
<p>Ну и еще раз <a title="jsfiddle.net" href="http://jsfiddle.net/STEVER/xub4ge4z/">весь код</a>.</p>
<h2>P.S.</h2>
<p>Крайне рекомендую поковыряться в исходниках <strong>AngularJS</strong>, вот <a title="rootScope.js#L721" href="https://github.com/angular/angular.js/blob/master/src/ng/rootScope.js#L363">тут</a>. Я вот внезапно обнаружил, что у <strong>$watch</strong> есть еще 4-тый недокументированный параметр prettyPrintExpression.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://stepansuvorov.com/blog/2015/03/simple-angular-digest/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
