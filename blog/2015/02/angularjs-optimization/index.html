<!DOCTYPE html>
<!--[if IE 6]>
<html id="ie6" lang="en-US">
<![endif]-->
<!--[if IE 7]>
<html id="ie7" lang="en-US">
<![endif]-->
<!--[if IE 8]>
<html id="ie8" lang="en-US">
<![endif]-->
<!--[if !(IE 6) & !(IE 7) & !(IE 8)]><!-->
<html lang="en-US">
<!--<![endif]-->

<!-- Mirrored from stepansuvorov.com/blog/2015/02/angularjs-optimization/ by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 11 Feb 2025 13:36:35 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width" />
<title>
Оптимизируем AngularJS. Подробный разбор. | Stepan Suvorov Blog	</title>
<link rel="profile" href="https://gmpg.org/xfn/11" />
<link rel="stylesheet" type="text/css" media="all" href="../../../wp-content/themes/twentyeleven/stylede5a.css?ver=20221126" />
<link rel="pingback" href="../../../xmlrpc.php">
<!--[if lt IE 9]>
<script src="https://stepansuvorov.com/blog/wp-content/themes/twentyeleven/js/html5.js?ver=3.7.0" type="text/javascript"></script>
<![endif]-->
<meta name='robots' content='max-image-preview:large' />
<link rel='dns-prefetch' href='http://www.googletagmanager.com/' />
<link rel='dns-prefetch' href='http://pagead2.googlesyndication.com/' />
<link rel="alternate" type="application/rss+xml" title="Stepan Suvorov Blog &raquo; Feed" href="../../../feed/index.html" />
<link rel="alternate" type="application/rss+xml" title="Stepan Suvorov Blog &raquo; Comments Feed" href="../../../comments/feed/index.html" />
<link rel="alternate" type="application/rss+xml" title="Stepan Suvorov Blog &raquo; Оптимизируем AngularJS. Подробный разбор. Comments Feed" href="feed/index.html" />
<script type="text/javascript">
window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/14.0.0\/72x72\/","ext":".png","svgUrl":"https:\/\/s.w.org\/images\/core\/emoji\/14.0.0\/svg\/","svgExt":".svg","source":{"concatemoji":"https:\/\/stepansuvorov.com\/blog\/wp-includes\/js\/wp-emoji-release.min.js?ver=6.3.1"}};
/*! This file is auto-generated */
!function(i,n){var o,s,e;function c(e){try{var t={supportTests:e,timestamp:(new Date).valueOf()};sessionStorage.setItem(o,JSON.stringify(t))}catch(e){}}function p(e,t,n){e.clearRect(0,0,e.canvas.width,e.canvas.height),e.fillText(t,0,0);var t=new Uint32Array(e.getImageData(0,0,e.canvas.width,e.canvas.height).data),r=(e.clearRect(0,0,e.canvas.width,e.canvas.height),e.fillText(n,0,0),new Uint32Array(e.getImageData(0,0,e.canvas.width,e.canvas.height).data));return t.every(function(e,t){return e===r[t]})}function u(e,t,n){switch(t){case"flag":return n(e,"\ud83c\udff3\ufe0f\u200d\u26a7\ufe0f","\ud83c\udff3\ufe0f\u200b\u26a7\ufe0f")?!1:!n(e,"\ud83c\uddfa\ud83c\uddf3","\ud83c\uddfa\u200b\ud83c\uddf3")&&!n(e,"\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc65\udb40\udc6e\udb40\udc67\udb40\udc7f","\ud83c\udff4\u200b\udb40\udc67\u200b\udb40\udc62\u200b\udb40\udc65\u200b\udb40\udc6e\u200b\udb40\udc67\u200b\udb40\udc7f");case"emoji":return!n(e,"\ud83e\udef1\ud83c\udffb\u200d\ud83e\udef2\ud83c\udfff","\ud83e\udef1\ud83c\udffb\u200b\ud83e\udef2\ud83c\udfff")}return!1}function f(e,t,n){var r="undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?new OffscreenCanvas(300,150):i.createElement("canvas"),a=r.getContext("2d",{willReadFrequently:!0}),o=(a.textBaseline="top",a.font="600 32px Arial",{});return e.forEach(function(e){o[e]=t(a,e,n)}),o}function t(e){var t=i.createElement("script");t.src=e,t.defer=!0,i.head.appendChild(t)}"undefined"!=typeof Promise&&(o="wpEmojiSettingsSupports",s=["flag","emoji"],n.supports={everything:!0,everythingExceptFlag:!0},e=new Promise(function(e){i.addEventListener("DOMContentLoaded",e,{once:!0})}),new Promise(function(t){var n=function(){try{var e=JSON.parse(sessionStorage.getItem(o));if("object"==typeof e&&"number"==typeof e.timestamp&&(new Date).valueOf()<e.timestamp+604800&&"object"==typeof e.supportTests)return e.supportTests}catch(e){}return null}();if(!n){if("undefined"!=typeof Worker&&"undefined"!=typeof OffscreenCanvas&&"undefined"!=typeof URL&&URL.createObjectURL&&"undefined"!=typeof Blob)try{var e="postMessage("+f.toString()+"("+[JSON.stringify(s),u.toString(),p.toString()].join(",")+"));",r=new Blob([e],{type:"text/javascript"}),a=new Worker(URL.createObjectURL(r),{name:"wpTestEmojiSupports"});return void(a.onmessage=function(e){c(n=e.data),a.terminate(),t(n)})}catch(e){}c(n=f(s,u,p))}t(n)}).then(function(e){for(var t in e)n.supports[t]=e[t],n.supports.everything=n.supports.everything&&n.supports[t],"flag"!==t&&(n.supports.everythingExceptFlag=n.supports.everythingExceptFlag&&n.supports[t]);n.supports.everythingExceptFlag=n.supports.everythingExceptFlag&&!n.supports.flag,n.DOMReady=!1,n.readyCallback=function(){n.DOMReady=!0}}).then(function(){return e}).then(function(){var e;n.supports.everything||(n.readyCallback(),(e=n.source||{}).concatemoji?t(e.concatemoji):e.wpemoji&&e.twemoji&&(t(e.twemoji),t(e.wpemoji)))}))}((window,document),window._wpemojiSettings);
</script>
<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 0.07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
	<link rel='stylesheet' id='wp-block-library-css' href='../../../wp-includes/css/dist/block-library/style.min9b30.css?ver=6.3.1' type='text/css' media='all' />
<style id='wp-block-library-theme-inline-css' type='text/css'>
.wp-block-audio figcaption{color:#555;font-size:13px;text-align:center}.is-dark-theme .wp-block-audio figcaption{color:hsla(0,0%,100%,.65)}.wp-block-audio{margin:0 0 1em}.wp-block-code{border:1px solid #ccc;border-radius:4px;font-family:Menlo,Consolas,monaco,monospace;padding:.8em 1em}.wp-block-embed figcaption{color:#555;font-size:13px;text-align:center}.is-dark-theme .wp-block-embed figcaption{color:hsla(0,0%,100%,.65)}.wp-block-embed{margin:0 0 1em}.blocks-gallery-caption{color:#555;font-size:13px;text-align:center}.is-dark-theme .blocks-gallery-caption{color:hsla(0,0%,100%,.65)}.wp-block-image figcaption{color:#555;font-size:13px;text-align:center}.is-dark-theme .wp-block-image figcaption{color:hsla(0,0%,100%,.65)}.wp-block-image{margin:0 0 1em}.wp-block-pullquote{border-bottom:4px solid;border-top:4px solid;color:currentColor;margin-bottom:1.75em}.wp-block-pullquote cite,.wp-block-pullquote footer,.wp-block-pullquote__citation{color:currentColor;font-size:.8125em;font-style:normal;text-transform:uppercase}.wp-block-quote{border-left:.25em solid;margin:0 0 1.75em;padding-left:1em}.wp-block-quote cite,.wp-block-quote footer{color:currentColor;font-size:.8125em;font-style:normal;position:relative}.wp-block-quote.has-text-align-right{border-left:none;border-right:.25em solid;padding-left:0;padding-right:1em}.wp-block-quote.has-text-align-center{border:none;padding-left:0}.wp-block-quote.is-large,.wp-block-quote.is-style-large,.wp-block-quote.is-style-plain{border:none}.wp-block-search .wp-block-search__label{font-weight:700}.wp-block-search__button{border:1px solid #ccc;padding:.375em .625em}:where(.wp-block-group.has-background){padding:1.25em 2.375em}.wp-block-separator.has-css-opacity{opacity:.4}.wp-block-separator{border:none;border-bottom:2px solid;margin-left:auto;margin-right:auto}.wp-block-separator.has-alpha-channel-opacity{opacity:1}.wp-block-separator:not(.is-style-wide):not(.is-style-dots){width:100px}.wp-block-separator.has-background:not(.is-style-dots){border-bottom:none;height:1px}.wp-block-separator.has-background:not(.is-style-wide):not(.is-style-dots){height:2px}.wp-block-table{margin:0 0 1em}.wp-block-table td,.wp-block-table th{word-break:normal}.wp-block-table figcaption{color:#555;font-size:13px;text-align:center}.is-dark-theme .wp-block-table figcaption{color:hsla(0,0%,100%,.65)}.wp-block-video figcaption{color:#555;font-size:13px;text-align:center}.is-dark-theme .wp-block-video figcaption{color:hsla(0,0%,100%,.65)}.wp-block-video{margin:0 0 1em}.wp-block-template-part.has-background{margin-bottom:0;margin-top:0;padding:1.25em 2.375em}
</style>
<style id='kevinbatdorf-code-block-pro-style-inline-css' type='text/css'>
.wp-block-kevinbatdorf-code-block-pro{box-sizing:border-box!important;direction:ltr!important;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;position:relative!important}.wp-block-kevinbatdorf-code-block-pro *{box-sizing:border-box!important}.wp-block-kevinbatdorf-code-block-pro pre,.wp-block-kevinbatdorf-code-block-pro pre *{font-size:inherit!important;line-height:inherit!important}.wp-block-kevinbatdorf-code-block-pro:not(.code-block-pro-editor) pre{--tw-shadow:0 0 #0000!important;--tw-shadow-colored:0 0 #0000!important;background-image:none!important;border:0!important;border-radius:0!important;border-style:none!important;border-width:0!important;box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)!important;color:inherit!important;font-family:inherit!important;margin:0!important;overflow:auto!important;overflow-wrap:normal!important;padding:16px 0 16px 16px!important;text-align:left!important;white-space:pre!important}.wp-block-kevinbatdorf-code-block-pro.padding-disabled:not(.code-block-pro-editor) pre{padding:0!important}.wp-block-kevinbatdorf-code-block-pro.padding-bottom-disabled pre{padding-bottom:0!important}.wp-block-kevinbatdorf-code-block-pro:not(.code-block-pro-editor) pre code{--tw-shadow:0 0 #0000!important;--tw-shadow-colored:0 0 #0000!important;background:none!important;background-color:transparent!important;border:0!important;border-radius:0!important;border-style:none!important;border-width:0!important;box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)!important;color:inherit!important;display:block!important;font-family:inherit!important;margin:0!important;overflow-wrap:normal!important;padding:0!important;text-align:left!important;white-space:pre!important;width:100%!important}.wp-block-kevinbatdorf-code-block-pro:not(.code-block-pro-editor) pre code .line{display:inline-block!important;min-width:var(--cbp-block-width,100%)!important;vertical-align:top!important}.wp-block-kevinbatdorf-code-block-pro.cbp-has-line-numbers:not(.code-block-pro-editor) pre code .line{padding-left:calc(12px + var(--cbp-line-number-width, auto))!important}.wp-block-kevinbatdorf-code-block-pro.cbp-has-line-numbers:not(.code-block-pro-editor) pre code{counter-increment:step calc(var(--cbp-line-number-start, 1) - 1)!important;counter-reset:step!important}.wp-block-kevinbatdorf-code-block-pro pre code .line{position:relative!important}.wp-block-kevinbatdorf-code-block-pro:not(.code-block-pro-editor) pre code .line:before{content:""!important;display:inline-block!important}.wp-block-kevinbatdorf-code-block-pro.cbp-has-line-numbers:not(.code-block-pro-editor) pre code .line:not(.cbp-line-number-disabled):before{color:var(--cbp-line-number-color,#999)!important;content:counter(step)!important;counter-increment:step!important;left:0!important;opacity:.5!important;position:absolute!important;text-align:right!important;transition-duration:.5s!important;transition-property:opacity!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important;-webkit-user-select:none!important;-moz-user-select:none!important;user-select:none!important;width:var(--cbp-line-number-width,auto)!important}.wp-block-kevinbatdorf-code-block-pro.cbp-highlight-hover .line{min-height:var(--cbp-block-height,100%)!important}.wp-block-kevinbatdorf-code-block-pro .line.cbp-line-highlight .cbp-line-highlighter,.wp-block-kevinbatdorf-code-block-pro .line.cbp-no-blur:hover .cbp-line-highlighter,.wp-block-kevinbatdorf-code-block-pro.cbp-highlight-hover:not(.cbp-blur-enabled:not(.cbp-unblur-on-hover)) .line:hover .cbp-line-highlighter{background:var(--cbp-line-highlight-color,rgb(14 165 233/.2))!important;left:-16px!important;min-height:var(--cbp-block-height,100%)!important;min-width:calc(var(--cbp-block-width, 100%) + 16px)!important;pointer-events:none!important;position:absolute!important;top:0!important;width:100%!important}[data-code-block-pro-font-family="Code-Pro-Comic-Mono.ttf"].wp-block-kevinbatdorf-code-block-pro .line.cbp-line-highlight .cbp-line-highlighter,[data-code-block-pro-font-family="Code-Pro-Comic-Mono.ttf"].wp-block-kevinbatdorf-code-block-pro .line.cbp-no-blur:hover .cbp-line-highlighter,[data-code-block-pro-font-family="Code-Pro-Comic-Mono.ttf"].wp-block-kevinbatdorf-code-block-pro.cbp-highlight-hover:not(.cbp-blur-enabled:not(.cbp-unblur-on-hover)) .line:hover .cbp-line-highlighter{top:-.125rem!important}[data-code-block-pro-font-family=Code-Pro-Fira-Code].wp-block-kevinbatdorf-code-block-pro .line.cbp-line-highlight .cbp-line-highlighter,[data-code-block-pro-font-family=Code-Pro-Fira-Code].wp-block-kevinbatdorf-code-block-pro .line.cbp-no-blur:hover .cbp-line-highlighter,[data-code-block-pro-font-family=Code-Pro-Fira-Code].wp-block-kevinbatdorf-code-block-pro.cbp-highlight-hover:not(.cbp-blur-enabled:not(.cbp-unblur-on-hover)) .line:hover .cbp-line-highlighter{top:-1.5px!important}.wp-block-kevinbatdorf-code-block-pro:not(.code-block-pro-editor).padding-disabled pre .line.cbp-line-highlight:after{left:0!important;width:100%!important}.wp-block-kevinbatdorf-code-block-pro.cbp-blur-enabled pre .line:not(.cbp-no-blur){filter:blur(1px)!important;opacity:.4!important;pointer-events:none!important;transition-duration:.2s!important;transition-property:all!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important}.wp-block-kevinbatdorf-code-block-pro.cbp-blur-enabled.cbp-unblur-on-hover:hover pre .line:not(.cbp-no-blur){--tw-blur:blur(0)!important;filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)!important;opacity:1!important;pointer-events:auto!important}.wp-block-kevinbatdorf-code-block-pro:not(.code-block-pro-editor) pre *{font-family:inherit!important}.cbp-see-more-simple-btn-hover{transition-property:none!important}.cbp-see-more-simple-btn-hover:hover{box-shadow:inset 0 0 100px 100px hsla(0,0%,100%,.1)!important}.code-block-pro-copy-button{background:none!important;background-color:transparent!important;border:0!important;border-style:none!important;border-width:0!important;cursor:pointer!important;left:auto!important;line-height:1!important;opacity:.1!important;padding:6px!important;position:absolute!important;right:0!important;top:0!important;transition-duration:.2s!important;transition-property:opacity!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important;z-index:10!important}.code-block-pro-copy-button:focus{opacity:.4!important}.wp-block-kevinbatdorf-code-block-pro.padding-disabled .code-block-pro-copy-button{padding:0!important}.wp-block-kevinbatdorf-code-block-pro:hover .code-block-pro-copy-button{opacity:.5!important}.wp-block-kevinbatdorf-code-block-pro .code-block-pro-copy-button:hover{opacity:.9!important}.code-block-pro-copy-button .without-check{display:block!important}.code-block-pro-copy-button .with-check,.code-block-pro-copy-button.cbp-copying .without-check{display:none!important}.code-block-pro-copy-button.cbp-copying .with-check{display:block!important}.cbp-footer-link:hover{text-decoration-line:underline!important}

</style>
<style id='classic-theme-styles-inline-css' type='text/css'>
/*! This file is auto-generated */
.wp-block-button__link{color:#fff;background-color:#32373c;border-radius:9999px;box-shadow:none;text-decoration:none;padding:calc(.667em + 2px) calc(1.333em + 2px);font-size:1.125em}.wp-block-file__button{background:#32373c;color:#fff;text-decoration:none}
</style>
<style id='global-styles-inline-css' type='text/css'>
body{--wp--preset--color--black: #000;--wp--preset--color--cyan-bluish-gray: #abb8c3;--wp--preset--color--white: #fff;--wp--preset--color--pale-pink: #f78da7;--wp--preset--color--vivid-red: #cf2e2e;--wp--preset--color--luminous-vivid-orange: #ff6900;--wp--preset--color--luminous-vivid-amber: #fcb900;--wp--preset--color--light-green-cyan: #7bdcb5;--wp--preset--color--vivid-green-cyan: #00d084;--wp--preset--color--pale-cyan-blue: #8ed1fc;--wp--preset--color--vivid-cyan-blue: #0693e3;--wp--preset--color--vivid-purple: #9b51e0;--wp--preset--color--blue: #1982d1;--wp--preset--color--dark-gray: #373737;--wp--preset--color--medium-gray: #666;--wp--preset--color--light-gray: #e2e2e2;--wp--preset--gradient--vivid-cyan-blue-to-vivid-purple: linear-gradient(135deg,rgba(6,147,227,1) 0%,rgb(155,81,224) 100%);--wp--preset--gradient--light-green-cyan-to-vivid-green-cyan: linear-gradient(135deg,rgb(122,220,180) 0%,rgb(0,208,130) 100%);--wp--preset--gradient--luminous-vivid-amber-to-luminous-vivid-orange: linear-gradient(135deg,rgba(252,185,0,1) 0%,rgba(255,105,0,1) 100%);--wp--preset--gradient--luminous-vivid-orange-to-vivid-red: linear-gradient(135deg,rgba(255,105,0,1) 0%,rgb(207,46,46) 100%);--wp--preset--gradient--very-light-gray-to-cyan-bluish-gray: linear-gradient(135deg,rgb(238,238,238) 0%,rgb(169,184,195) 100%);--wp--preset--gradient--cool-to-warm-spectrum: linear-gradient(135deg,rgb(74,234,220) 0%,rgb(151,120,209) 20%,rgb(207,42,186) 40%,rgb(238,44,130) 60%,rgb(251,105,98) 80%,rgb(254,248,76) 100%);--wp--preset--gradient--blush-light-purple: linear-gradient(135deg,rgb(255,206,236) 0%,rgb(152,150,240) 100%);--wp--preset--gradient--blush-bordeaux: linear-gradient(135deg,rgb(254,205,165) 0%,rgb(254,45,45) 50%,rgb(107,0,62) 100%);--wp--preset--gradient--luminous-dusk: linear-gradient(135deg,rgb(255,203,112) 0%,rgb(199,81,192) 50%,rgb(65,88,208) 100%);--wp--preset--gradient--pale-ocean: linear-gradient(135deg,rgb(255,245,203) 0%,rgb(182,227,212) 50%,rgb(51,167,181) 100%);--wp--preset--gradient--electric-grass: linear-gradient(135deg,rgb(202,248,128) 0%,rgb(113,206,126) 100%);--wp--preset--gradient--midnight: linear-gradient(135deg,rgb(2,3,129) 0%,rgb(40,116,252) 100%);--wp--preset--font-size--small: 13px;--wp--preset--font-size--medium: 20px;--wp--preset--font-size--large: 36px;--wp--preset--font-size--x-large: 42px;--wp--preset--spacing--20: 0.44rem;--wp--preset--spacing--30: 0.67rem;--wp--preset--spacing--40: 1rem;--wp--preset--spacing--50: 1.5rem;--wp--preset--spacing--60: 2.25rem;--wp--preset--spacing--70: 3.38rem;--wp--preset--spacing--80: 5.06rem;--wp--preset--shadow--natural: 6px 6px 9px rgba(0, 0, 0, 0.2);--wp--preset--shadow--deep: 12px 12px 50px rgba(0, 0, 0, 0.4);--wp--preset--shadow--sharp: 6px 6px 0px rgba(0, 0, 0, 0.2);--wp--preset--shadow--outlined: 6px 6px 0px -3px rgba(255, 255, 255, 1), 6px 6px rgba(0, 0, 0, 1);--wp--preset--shadow--crisp: 6px 6px 0px rgba(0, 0, 0, 1);}:where(.is-layout-flex){gap: 0.5em;}:where(.is-layout-grid){gap: 0.5em;}body .is-layout-flow > .alignleft{float: left;margin-inline-start: 0;margin-inline-end: 2em;}body .is-layout-flow > .alignright{float: right;margin-inline-start: 2em;margin-inline-end: 0;}body .is-layout-flow > .aligncenter{margin-left: auto !important;margin-right: auto !important;}body .is-layout-constrained > .alignleft{float: left;margin-inline-start: 0;margin-inline-end: 2em;}body .is-layout-constrained > .alignright{float: right;margin-inline-start: 2em;margin-inline-end: 0;}body .is-layout-constrained > .aligncenter{margin-left: auto !important;margin-right: auto !important;}body .is-layout-constrained > :where(:not(.alignleft):not(.alignright):not(.alignfull)){max-width: var(--wp--style--global--content-size);margin-left: auto !important;margin-right: auto !important;}body .is-layout-constrained > .alignwide{max-width: var(--wp--style--global--wide-size);}body .is-layout-flex{display: flex;}body .is-layout-flex{flex-wrap: wrap;align-items: center;}body .is-layout-flex > *{margin: 0;}body .is-layout-grid{display: grid;}body .is-layout-grid > *{margin: 0;}:where(.wp-block-columns.is-layout-flex){gap: 2em;}:where(.wp-block-columns.is-layout-grid){gap: 2em;}:where(.wp-block-post-template.is-layout-flex){gap: 1.25em;}:where(.wp-block-post-template.is-layout-grid){gap: 1.25em;}.has-black-color{color: var(--wp--preset--color--black) !important;}.has-cyan-bluish-gray-color{color: var(--wp--preset--color--cyan-bluish-gray) !important;}.has-white-color{color: var(--wp--preset--color--white) !important;}.has-pale-pink-color{color: var(--wp--preset--color--pale-pink) !important;}.has-vivid-red-color{color: var(--wp--preset--color--vivid-red) !important;}.has-luminous-vivid-orange-color{color: var(--wp--preset--color--luminous-vivid-orange) !important;}.has-luminous-vivid-amber-color{color: var(--wp--preset--color--luminous-vivid-amber) !important;}.has-light-green-cyan-color{color: var(--wp--preset--color--light-green-cyan) !important;}.has-vivid-green-cyan-color{color: var(--wp--preset--color--vivid-green-cyan) !important;}.has-pale-cyan-blue-color{color: var(--wp--preset--color--pale-cyan-blue) !important;}.has-vivid-cyan-blue-color{color: var(--wp--preset--color--vivid-cyan-blue) !important;}.has-vivid-purple-color{color: var(--wp--preset--color--vivid-purple) !important;}.has-black-background-color{background-color: var(--wp--preset--color--black) !important;}.has-cyan-bluish-gray-background-color{background-color: var(--wp--preset--color--cyan-bluish-gray) !important;}.has-white-background-color{background-color: var(--wp--preset--color--white) !important;}.has-pale-pink-background-color{background-color: var(--wp--preset--color--pale-pink) !important;}.has-vivid-red-background-color{background-color: var(--wp--preset--color--vivid-red) !important;}.has-luminous-vivid-orange-background-color{background-color: var(--wp--preset--color--luminous-vivid-orange) !important;}.has-luminous-vivid-amber-background-color{background-color: var(--wp--preset--color--luminous-vivid-amber) !important;}.has-light-green-cyan-background-color{background-color: var(--wp--preset--color--light-green-cyan) !important;}.has-vivid-green-cyan-background-color{background-color: var(--wp--preset--color--vivid-green-cyan) !important;}.has-pale-cyan-blue-background-color{background-color: var(--wp--preset--color--pale-cyan-blue) !important;}.has-vivid-cyan-blue-background-color{background-color: var(--wp--preset--color--vivid-cyan-blue) !important;}.has-vivid-purple-background-color{background-color: var(--wp--preset--color--vivid-purple) !important;}.has-black-border-color{border-color: var(--wp--preset--color--black) !important;}.has-cyan-bluish-gray-border-color{border-color: var(--wp--preset--color--cyan-bluish-gray) !important;}.has-white-border-color{border-color: var(--wp--preset--color--white) !important;}.has-pale-pink-border-color{border-color: var(--wp--preset--color--pale-pink) !important;}.has-vivid-red-border-color{border-color: var(--wp--preset--color--vivid-red) !important;}.has-luminous-vivid-orange-border-color{border-color: var(--wp--preset--color--luminous-vivid-orange) !important;}.has-luminous-vivid-amber-border-color{border-color: var(--wp--preset--color--luminous-vivid-amber) !important;}.has-light-green-cyan-border-color{border-color: var(--wp--preset--color--light-green-cyan) !important;}.has-vivid-green-cyan-border-color{border-color: var(--wp--preset--color--vivid-green-cyan) !important;}.has-pale-cyan-blue-border-color{border-color: var(--wp--preset--color--pale-cyan-blue) !important;}.has-vivid-cyan-blue-border-color{border-color: var(--wp--preset--color--vivid-cyan-blue) !important;}.has-vivid-purple-border-color{border-color: var(--wp--preset--color--vivid-purple) !important;}.has-vivid-cyan-blue-to-vivid-purple-gradient-background{background: var(--wp--preset--gradient--vivid-cyan-blue-to-vivid-purple) !important;}.has-light-green-cyan-to-vivid-green-cyan-gradient-background{background: var(--wp--preset--gradient--light-green-cyan-to-vivid-green-cyan) !important;}.has-luminous-vivid-amber-to-luminous-vivid-orange-gradient-background{background: var(--wp--preset--gradient--luminous-vivid-amber-to-luminous-vivid-orange) !important;}.has-luminous-vivid-orange-to-vivid-red-gradient-background{background: var(--wp--preset--gradient--luminous-vivid-orange-to-vivid-red) !important;}.has-very-light-gray-to-cyan-bluish-gray-gradient-background{background: var(--wp--preset--gradient--very-light-gray-to-cyan-bluish-gray) !important;}.has-cool-to-warm-spectrum-gradient-background{background: var(--wp--preset--gradient--cool-to-warm-spectrum) !important;}.has-blush-light-purple-gradient-background{background: var(--wp--preset--gradient--blush-light-purple) !important;}.has-blush-bordeaux-gradient-background{background: var(--wp--preset--gradient--blush-bordeaux) !important;}.has-luminous-dusk-gradient-background{background: var(--wp--preset--gradient--luminous-dusk) !important;}.has-pale-ocean-gradient-background{background: var(--wp--preset--gradient--pale-ocean) !important;}.has-electric-grass-gradient-background{background: var(--wp--preset--gradient--electric-grass) !important;}.has-midnight-gradient-background{background: var(--wp--preset--gradient--midnight) !important;}.has-small-font-size{font-size: var(--wp--preset--font-size--small) !important;}.has-medium-font-size{font-size: var(--wp--preset--font-size--medium) !important;}.has-large-font-size{font-size: var(--wp--preset--font-size--large) !important;}.has-x-large-font-size{font-size: var(--wp--preset--font-size--x-large) !important;}
.wp-block-navigation a:where(:not(.wp-element-button)){color: inherit;}
:where(.wp-block-post-template.is-layout-flex){gap: 1.25em;}:where(.wp-block-post-template.is-layout-grid){gap: 1.25em;}
:where(.wp-block-columns.is-layout-flex){gap: 2em;}:where(.wp-block-columns.is-layout-grid){gap: 2em;}
.wp-block-pullquote{font-size: 1.5em;line-height: 1.6;}
</style>
<link rel='stylesheet' id='wprc-style-css' href='../../../wp-content/plugins/report-content/static/css/styles9b30.css?ver=6.3.1' type='text/css' media='all' />
<link rel='stylesheet' id='twentyeleven-block-style-css' href='../../../wp-content/themes/twentyeleven/blocks03d3.css?ver=20230122' type='text/css' media='all' />
<script type='text/javascript' src='../../../wp-includes/js/jquery/jquery.min3088.js?ver=3.7.0' id='jquery-core-js'></script>
<script type='text/javascript' src='../../../wp-includes/js/jquery/jquery-migrate.min5589.js?ver=3.4.1' id='jquery-migrate-js'></script>
<script type='text/javascript' id='wprc-script-js-extra'>
/* <![CDATA[ */
var wprcajaxhandler = {"ajaxurl":"https:\/\/stepansuvorov.com\/blog\/wp-admin\/admin-ajax.php"};
/* ]]> */
</script>
<script type='text/javascript' src='../../../wp-content/plugins/report-content/static/js/scripts9b30.js?ver=6.3.1' id='wprc-script-js'></script>

<!-- Google Analytics snippet added by Site Kit -->
<script type='text/javascript' src='https://www.googletagmanager.com/gtag/js?id=GT-5NXW8XZ' id='google_gtagjs-js' async></script>
<script id="google_gtagjs-js-after" type="text/javascript">
window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}
gtag('set', 'linker', {"domains":["stepansuvorov.com"]} );
gtag("js", new Date());
gtag("set", "developer_id.dZTNiMT", true);
gtag("config", "GT-5NXW8XZ");
</script>

<!-- End Google Analytics snippet added by Site Kit -->
<link rel="https://api.w.org/" href="../../../wp-json/index.html" /><link rel="alternate" type="application/json" href="../../../wp-json/wp/v2/posts/2063.json" /><link rel="EditURI" type="application/rsd+xml" title="RSD" href="../../../xmlrpc0db0.php?rsd" />
<meta name="generator" content="WordPress 6.3.1" />
<link rel="canonical" href="index.html" />
<link rel='shortlink' href='../../../index1ab8.html?p=2063' />
<link rel="alternate" type="application/json+oembed" href="../../../wp-json/oembed/1.0/embedb2ab.json?url=https%3A%2F%2Fstepansuvorov.com%2Fblog%2F2015%2F02%2Fangularjs-optimization%2F" />
<link rel="alternate" type="text/xml+oembed" href="../../../wp-json/oembed/1.0/embed138a?url=https%3A%2F%2Fstepansuvorov.com%2Fblog%2F2015%2F02%2Fangularjs-optimization%2F&amp;format=xml" />
<meta name="generator" content="Site Kit by Google 1.110.0" /><meta name="google-site-verification" content="xt946WTH7xxkpeWcqzwQ1xmLLmr91UbOF6VSIl7m5rk">
<!-- Google AdSense snippet added by Site Kit -->
<meta name="google-adsense-platform-account" content="ca-host-pub-2644536267352236">
<meta name="google-adsense-platform-domain" content="sitekit.withgoogle.com">
<!-- End Google AdSense snippet added by Site Kit -->

<!-- Google AdSense snippet added by Site Kit -->
<script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2931348686023542&amp;host=ca-host-pub-2644536267352236" crossorigin="anonymous" type="text/javascript"></script>

<!-- End Google AdSense snippet added by Site Kit -->
</head>

<body class="post-template-default single single-post postid-2063 single-format-standard wp-embed-responsive single-author singular two-column right-sidebar">
<div class="skip-link"><a class="assistive-text" href="#content">Skip to primary content</a></div><div id="page" class="hfeed">
	<header id="branding">
			<hgroup>
				<h1 id="site-title"><span><a href="../../../index.html" rel="home">Stepan Suvorov Blog</a></span></h1>
				<h2 id="site-description">Release 2.0</h2>
			</hgroup>

						<a href="../../../index.html">
									<img src="../../../wp-content/uploads/2012/03/cropped-DSC_0768_1.jpg" width="1000" height="288" alt="Stepan Suvorov Blog" />
								</a>
			
									<form method="get" id="searchform" action="https://stepansuvorov.com/blog/">
		<label for="s" class="assistive-text">Search</label>
		<input type="text" class="field" name="s" id="s" placeholder="Search" />
		<input type="submit" class="submit" name="submit" id="searchsubmit" value="Search" />
	</form>
			
			<nav id="access">
				<h3 class="assistive-text">Main menu</h3>
				<div class="menu-menu-1-container"><ul id="menu-menu-1" class="menu"><li id="menu-item-3600" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-3600"><a href="../../../index.html">Home</a></li>
<li id="menu-item-3602" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-3602"><a href="../../../useful-linux-comands/index.html">shell tricks</a></li>
<li id="menu-item-3603" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-3603"><a href="../../../subscribe/index.html">Subscribe</a></li>
<li id="menu-item-3604" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-3604"><a href="../../../i-use/index.html">I use</a></li>
<li id="menu-item-3606" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-3606"><a href="https://stepansuvorov.com/">me</a></li>
</ul></div>			</nav><!-- #access -->
	</header><!-- #branding -->


	<div id="main">

		<div id="primary">
			<div id="content" role="main">

				
					<nav id="nav-single">
						<h3 class="assistive-text">Post navigation</h3>
						<span class="nav-previous"><a href="../../01/front-end-monitoring-services/index.html" rel="prev"><span class="meta-nav">&larr;</span> Previous</a></span>
						<span class="nav-next"><a href="../ng-nl-brief-review/index.html" rel="next">Next <span class="meta-nav">&rarr;</span></a></span>
					</nav><!-- #nav-single -->

					
<article id="post-2063" class="post-2063 post type-post status-publish format-standard hentry category-4 tag-angularjs tag-chrome tag-javascript tag-performance tag-snippet tag-344">
	<header class="entry-header">
		<h1 class="entry-title">Оптимизируем AngularJS. Подробный разбор.</h1>

				<div class="entry-meta">
			<span class="sep">Posted on </span><a href="index.html" title="12:10" rel="bookmark"><time class="entry-date" datetime="2015-02-10T12:10:06+02:00">10.02.15</time></a><span class="by-author"> <span class="sep"> by </span> <span class="author vcard"><a class="url fn n" href="../../../author/admin/index.html" title="View all posts by Stepan" rel="author">Stepan</a></span></span>		</div><!-- .entry-meta -->
			</header><!-- .entry-header -->

	<div class="entry-content">
		<p>Вольный перевод статьи &#8220;<a href="http://bahmutov.calepin.co/improving-angular-web-app-performance-example.html">Improving Angular web app performance example</a>&#8220;. Трактат довольно фундаментальный. Большая часть методик оценки производительности подойдет для любого веб-приложения (не только AngularJS).</p>
<p>Состоит из следующих разделов:</p>
<ul>
<li><a href="#not-optimized-example">Пример не оптимизированного приложения</a></li>
<li><a href="#quick-performance-overview">Поверхностная оценка производительности</a></li>
<li><a href="#profiling-with-snippets">Профилирование в Chrome с использованием сниппетов</a></li>
<li><a href="#digest-optimization">Оптимизация цикла дайджеста</a></li>
<li><a href="#bind-once">Использование директивы bind-once</a></li>
<li><a href="#get-rid-off-ng-repeat">Избавляемся от ng-repeat</a></li>
<li><a href="#initial-rendering">Ускоряем начальный рендеринг</a></li>
<li><a href="#in-to-pieces">Разбиваем &#8220;тяжелые&#8221; компоненты на небольшие части</a></li>
<li><a href="#web-workers">Перекладываем вычисления на WebWorkers</a></li>
<li><a href="#memory-allocation-optimization">Оптимизация процесса выделения памяти</a></li>
<li><a href="#memory-profile-isolation">Изоляция профиля памяти</a></li>
<li><a href="#on-request-compulation">Вычисление только по запросу</a></li>
<li><a href="#watched-objects-minimization">Минимизация наблюдаемых объектов</a></li>
<li><a href="#conclusions">Выводы</a></li>
</ul>
<p><span id="more-2063"></span></p>
<p>Как только необходимая функциональность вашего <strong>AngularJS</strong> приложения готова, следующий шаг &#8211; работа над <strong>производительностью</strong>, то есть: начальное время загрузки, отзывчивость к действиям пользователя: приложение должно работать быстро не заставляя пользователя ждать, иначе оно будет не очень удобным. Существую множество различных советов по повышению производительности, например: Steven Czerwinksi в своем посте &#8220;<a title="blog.scalyr.com" href="http://blog.scalyr.com/2013/10/angularjs-1200ms-to-35ms/">Optimizing AngularJS: 1200ms to 35ms</a>&#8221; предлагает следующие шаги:</p>
<ul>
<li>кеширование DOM элементов</li>
<li>сокращение количества вотчеров</li>
<li>отложенное создание элемента</li>
<li>пропускать вотчеры спрятанных элементов</li>
</ul>
<p>Я считаю все эти советы приемлемыми, но слишком сложными в правильной реализации. Вместо них я предлагаю следующие:</p>
<ul>
<li>Индивидуальная функциональность
<ul>
<li>оптимизировать <strong>очевидные узкие места</strong> на <strong>JavaScript</strong> (не AngularJS)</li>
</ul>
</li>
<li>Оценить и оптимизировать холостые проходы цикла дайджеста
<ul>
<li>удалить <strong>ненужные фильтры</strong> (тем самым сократив количество вотчеров)</li>
<li>удалить ненужные вотчеры переходом от <strong>двунаправленого</strong> связывания к <strong>одностороннему</strong></li>
</ul>
</li>
<li>Проанализировать все места <strong>обновления DOM</strong>
<ul>
<li>тяжелые операции могут быть разбиты на более <strong>простые модули </strong></li>
<li>некоторые манипуляции могут быть сделаны за чет <strong>вебворкеров</strong></li>
</ul>
</li>
<li>Минимизировать события по <strong>сборке мусора</strong>
<ul>
<li><strong>Повторно использовать память</strong> вместо выделения новой</li>
</ul>
</li>
</ul>
<h2></h2>
<h2 id="not-optimized-example">Пример не оптимизированного приложения</h2>
<p>В примере используется <strong>AngularJS 1.2</strong>, но техники профилирования приложения и нахождения &#8220;узких мест&#8221; могут быть применимы так же  и для последующих версий.</p>
<p>Для примера я написал небольшое <strong>AngularJS</strong> приложение( исходный код доступен <a title="github.com" href="https://github.com/bahmutov/primes">тут</a>). Весь пример помещен в <code>index.html</code> файл, который может быть открыт в браузере (то есть веб сервер для запуска не нужен). Задача приложения  &#8211; вычислить N <a title="ru.wikipedia.org" href="http://ru.wikipedia.org/wiki/Простое_число">простых чисел</a>. Начнем мы с крайне неэффективной реализации и шаг за шагом будем улучшать ее.</p>
<p>Разворачиваем приложение локально:</p>
<p>[shell]<br />
git clone git@github.com:bahmutov/primes.git<br />
cd primes<br />
bower install angular-bindonce jquery angular-vs-repeat &#8211;force<br />
git checkout step-0<br />
[/shell]</p>
<p>Откроем <code>index.html</code>. Страница выглядит очень просто: пользователь вводит желаемое число простых чисел и нажимает &#8220;Find&#8221;. После чего числа вычисляются и выводятся в таблицу:</p>
<p>[html]<br />
&lt;div ng-controller=&quot;primesController&quot; ng-cloak&gt;<br />
  &lt;button id=&quot;find&quot; ng-click=&quot;find()&quot;&gt;Find&lt;/button&gt; &lt;input ng-model=&quot;n&quot; /&gt; primes.<br />
  &lt;table&gt;<br />
    &lt;tr ng-repeat=&quot;prime in primes | orderBy:$index &quot;&gt;<br />
      &lt;td&gt;{{ &quot;index&quot; | lowercase }}&lt;/td&gt;<br />
      &lt;td&gt;{{ $index + 1 | number:0 | uppercase }}&lt;/td&gt;<br />
      &lt;td&gt;{{ &quot;prime number&quot; | lowercase }}&lt;/td&gt;<br />
      &lt;td&gt;{{ prime | number:0 | uppercase }}&lt;/td&gt;<br />
      &lt;td&gt;is prime? {{ prime | isPrime }}&lt;/td&gt;<br />
    &lt;/tr&gt;<br />
  &lt;/table&gt;<br />
&lt;/div&gt;<br />
[/html]</p>
<p>Таблица содержит фильтры и порядок, чтобы показывать проблемы производительности с ними связанные.</p>
<p>Первый 5 простых чисел выглядят так:</p>
<p><img decoding="async" fetchpriority="high" class="alignnone size-full wp-image-2278" src="../../../wp-content/uploads/2015/02/primes.png" alt="primes" width="752" height="464" /></p>
<h2 id="quick-performance-overview">Поверхностная оценка производительности</h2>
<p>Первоначальная версия довольно быстро находит первые 10 или даже 100 простых чисел. Но если попробовать найти 1000, то обязательно приложение начнет тормозить. Откуда такие тормоза?</p>
<p>Код AngularJS приложения довольно простой:</p>
<p>[javascript]<br />
function isPrime() &#8230;<br />
function findPrime() &#8230;<br />
angular.module(&#8216;Primes&#8217;, [])<br />
  .filter(&#8216;isPrime&#8217;, function () {<br />
    return isPrime;<br />
  })<br />
  .controller(&#8216;primesController&#8217;, function ($scope) {<br />
    $scope.n = 10;<br />
    $scope.find = function () {<br />
      console.log(&#8216;computing first&#8217;, $scope.n, &#8216;primes&#8217;);<br />
      $scope.primes = [];<br />
      var k;<br />
      for (k = 0; k &lt; $scope.n; k += 1) {<br />
        var prime = findPrime(k + 2);<br />
        $scope.primes.push(prime);<br />
      }<br />
    };<br />
  });</p>
<p>[/javascript]</p>
<p>метод <code>$scope.find</code> выполняется очень долго для большого значения <code>$scope.n</code>. Обычно мы начинаем профилирование JavaScript вот так:</p>
<p>[javascript]<br />
$scope.find = function () {<br />
  console.log(&#8216;computing first&#8217;, $scope.n, &#8216;primes&#8217;);<br />
  var started = new Date();<br />
  // computation<br />
  var finished = new Date();<br />
  console.log(&#8216;find took&#8217;, finished &#8211; started, &#8216;ms&#8217;);<br />
};<br />
[/javascript]</p>
<p>Я предпочитаю <a title="https://developer.chrome.com/devtools/docs/console-api#consoletimelabel" href="https://developer.chrome.com/devtools/docs/console-api#consoletimelabel">console.time</a> &#8211; что позволяет использовать меньше дополнительных переменных.</p>
<p>[javascript]<br />
$scope.find = function () {<br />
  console.log(&#8216;computing first&#8217;, $scope.n, &#8216;primes&#8217;);<br />
  console.time(&#8216;computing primes&#8217;);<br />
  // computation<br />
  console.timeEnd(&#8216;computing primes&#8217;);<br />
};<br />
[/javascript]</p>
<p>для 1000 у меня выдало</p>
<pre>computing primes: 13084.714ms</pre>
<p>То есть расчет занял 13 секунд!</p>
<h2 id="profiling-with-snippets">Профилирование в Chrome с использованием сниппетов</h2>
<p>Вместо того, чтобы править код и вставлять метки времени, я использую <a href="https://github.com/bahmutov/code-snippets/blob/master/ng-profile-scope-method.js">ng-profile-scope-method</a> сниппет (о сниппетах можно почитать <a title="JavaScript сниппеты в Chrome" href="../../01/javascript-%d1%81%d0%bd%d0%b8%d0%bf%d0%bf%d0%b5%d1%82%d1%8b-%d0%b2-chrome/index.html">тут</a>). В этом методе зафиксированы id элемента и имя анализируемого метода (в нашем случае это &#8220;<em>find</em>&#8220;, но вы можете их легко поменять профилируя другое приложение).</p>
<p>Запускаем сниппет, нажимаем на &#8220;Find&#8221;, смотрим результаты:</p>
<p><img decoding="async" class="alignnone size-full wp-image-2279" src="../../../wp-content/uploads/2015/02/Screenshot-2015-02-01-11.03.19.png" alt="ng-profile-scope-method" width="439" height="600" /></p>
<p>Когда метод закончит работу, мы можем перейти во кладку <strong>Profiles</strong> и посмотреть загруженность процессора в момент выполнения метода. Начнем разбор с представления &#8220;<strong>Chart</strong>&#8220;:</p>
<p><img decoding="async" class="alignnone size-full wp-image-2283" src="../../../wp-content/uploads/2015/02/Screenshot-2015-02-02-11.44.24.png" alt="cpu profiling" width="579" height="541" /></p>
<p>Отметим, что стек вызовов тривиален: функция обработчика события выполняется всего один раз за эти 13 секунд, так же как <code>$apply</code>, <code>$eval</code> и так до <code>$scope.find</code>. Внутри нашего метода <code>find</code> мы видим множественные вызовы к функции <code>findPrime</code>. Давайте посмотрим является ли <code>findPrime</code> &#8220;узким местом&#8221; для производительности.</p>
<p>Переключимся из предстваления &#8220;<strong>Chart</strong>&#8221; в &#8220;<strong>Heavy</strong>&#8220;. Оно показывает функции, расположенные в порядке убывания по времени выполнения. <img decoding="async" loading="lazy" class="alignnone size-full wp-image-2284" src="../../../wp-content/uploads/2015/02/Screenshot-2015-02-02-11.52.03.png" alt="cpu profiling 2" width="746" height="454" /></p>
<p>В топе мы видим 2 функции &#8211; <code>isPrime</code> и <code>findPrime</code>, которые выполняются дольше всех. Обратите внимание на желтый треугольничек рядом с <code>isPrime</code>. Если вы наведете на него мышкой, то увидите всплывающую подсказку о том, что метод не может быть оптимизирован компилятором &#8220;<a title="wiki" href="https://ru.wikipedia.org/wiki/JIT-компиляция">на лету</a>&#8220;. В данном случае это из-за <code>try-catch</code>, который находится внутри функции.</p>
<p>В нашем случае <code>isPrime</code> не требует <code>try-catch</code> блока совсем:</p>
<p>[javascript]<br />
function isPrime(n) {<br />
  try {<br />
    var k;<br />
    for (k = 2; k &lt; n; k += 1) {<br />
      if (n % k === 0) {<br />
        return false;<br />
      }<br />
    }<br />
  } catch (err) {<br />
    console.error(err);<br />
  }<br />
  return true;<br />
}<br />
[/javascript]</p>
<p>Уберем его и запустим профайлер еще раз:</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2285" src="../../../wp-content/uploads/2015/02/Screenshot-2015-02-02-12.07.51.png" alt="cpu-profiling 3" width="598" height="466" /></p>
<p>после чего мы видим как время выполнение <code>isPrime</code> с 7.2 секунд упало до 40 миллисекунд, а общее время выполнения с 13 до 5,8 секунд. Сниппет позволяет сохранять профили для разных запусков отдельно, что дает нам возможность сравнить их.</p>
<p>Итак, <code>findPrime</code> &#8211; наша новая цель для оптимизации. Давайте посмотрим на исходник:</p>
<p>[javascript]<br />
function findPrime(n) {<br />
  var k = 1;<br />
  var foundPrimes = [];<br />
  while (foundPrimes.length &lt; n) {<br />
    if (isPrime(k)) {<br />
      foundPrimes.push(k);<br />
    }<br />
    k += 1;<br />
  };<br />
  return foundPrimes[foundPrimes.length &#8211; 1];<br />
}<br />
[/javascript]</p>
<p>Функция ищет N-ое простое число по средством вычисления всех предшествующих и возвращает последнее. Но при этом для нахождения следующего (N + 1) числа она проделает все сначала. Давайте попробуем использовать ранее найденые простые числа вынеся массив <code>foundPrimes</code> за пределы функции:</p>
<p>[javascript]<br />
var foundPrimes = [];<br />
function findPrime(n) {<br />
  var k;<br />
  if (foundPrimes.length) {<br />
    k = foundPrimes[foundPrimes.length &#8211; 1] + 1;<br />
  } else {<br />
    k = 1;<br />
  }<br />
  while (foundPrimes.length &lt; n) {<br />
    if (isPrime(k)) {<br />
      foundPrimes.push(k);<br />
    }<br />
    k += 1;<br />
  };<br />
  return foundPrimes[n &#8211; 1];<br />
}<br />
[/javascript]</p>
<p>Изменения (тег <a href="https://github.com/bahmutov/primes/releases/tag/step-2">step-2</a>) приводят к серьезному скачку производительности:</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2286" src="../../../wp-content/uploads/2015/02/Screenshot-2015-02-02-12.43.07.png" alt="cpu-profiling 4" width="631" height="376" /></p>
<p>Теперь весь метод <code>$scope.find</code> выполняется за 389 мс, то есть скорость по сравнению с первоначальным вариантом увеличилась более чем в 40 раз!</p>
<p>Мы можем сделать еще одну простое изменение с целью оптимизации функции <code>isPrime</code>: тут больше вопрос математики &#8211; проверяя N на простоту, нам не нужно проверять остаток от деления на все простые числа идущие до него &#8211; достаточно дойти до корня из N:</p>
<p>[javascript]<br />
function isPrime(n) {<br />
  var k;<br />
  var limit = Math.sqrt(n);<br />
  for (k = 2; k &lt;= limit; k += 1) {<br />
    if (n % k === 0) {<br />
      return false;<br />
    }<br />
  }<br />
  return true;<br />
}<br />
[/javascript]</p>
<p>Обновить код можно перейдя к тегу <a href="https://github.com/bahmutov/primes/releases/tag/step-3">step-3</a>. Профайлер <code>$scope.find</code> показывает что мы избавились от всех явных тормозов:</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2287" src="../../../wp-content/uploads/2015/02/Screenshot-2015-02-02-12.59.00.png" alt="cpu-profiling 4" width="605" height="379" /></p>
<h2 id="digest-optimization">Оптимизация цикла дайджеста</h2>
<p>Теперь можем переходить к профилирования метода объекта <code>scope</code>. Чтобы точно выявить слабые места, сделаем оценку на более серьезном объеме входных данных. Но сначала я добавлю небольшую деталь: вывод количества простых чисел (изменение в теге <a href="https://github.com/bahmutov/primes/releases/tag/step-4">step-4</a>):</p>
<p>[html]<br />
&lt;button id=&quot;find&quot; ng-click=&quot;find()&quot;&gt;Find&lt;/button&gt; &lt;input ng-model=&quot;n&quot; /&gt; primes.<br />
&lt;p&gt;AngularJs application that finds first {{ n }} prime numbers&lt;/p&gt;<br />
[/html]</p>
<p>Давайте попробуем сгенерировать 100 000 простых чисел. Это займет несколько секунд ( обновления DOM). Как только 100 000 простых чисел будут выведены на экран, попробуйте поменять количество (например: удалить один ноль). Обратите внимание на существенную задержку после нажатия на кнопку и обновления данных. Мы не модифицируем данные модели, только одно число. Таблица не должна обновляться, откуда задержка?</p>
<p>Чтобы отдебажить эту проблему давайте используем другой сниппет &#8211; <a href="https://github.com/bahmutov/code-snippets/blob/master/ng-idle-apply-timing.js">ng-idle-apply-timing</a> (опять таки ничего не изменяя в коде). Он покажет сколько времени занимает грязная проверка (dirty checking) каждой переменной  в нашем приложении. Двойное связывание, $watch выражения и фильтры &#8211;  все это делает проход цикла дайджста более медленным.</p>
<p>Взглянем что получилось в профайле:</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2288" src="../../../wp-content/uploads/2015/02/Screenshot-2015-02-02-16.15.37.png" alt="scope digest profiling" width="664" height="399" /></p>
<p>Мы видим, что только на цикл дайджеста уходит больше секунды (1274 мс). Хотелось бы это исправить. Самый надежный способ ускорить работу дайджеста &#8211; повыкидывать ненужные вотчеры.</p>
<p>Для начала посмотрим на элементы с самыми медленными вотчерами. Используем еще 2 сниппета: сначала <a href="https://github.com/bahmutov/code-snippets/blob/master/ng-profile-local-digest.js">ng-profile-local-digest.js</a>, после чего &#8211; <a href="https://github.com/bahmutov/code-snippets/blob/master/ng-find-expensive-digest.js">ng-find-expensive-digest.js</a> (так исторически сложилось, что второй требует метод, который определяется в первом). Просто запустите их один за одним. И у нас в консоли появится вспомогательный метод <code>findExpensiveDigest</code>, который можем выполнить для таблицы и поля ввода:</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2290" src="../../../wp-content/uploads/2015/02/Screenshot-2015-02-03-11.34.21.png" alt="digest profiling" width="475" height="138" /></p>
<p>Используем сниппет &#8211; <a href="https://github.com/bahmutov/code-snippets/blob/master/ng-count-watchers.js">ng-count-watchers</a>, чтобы посчитать общее количество вотчеров. Можете убедиться, что для случая с 100 000 простыми числами в приложении появляется аж 500 003 вотчеров! Из них 3 &#8211; обслуживают ng-repeat, вводимое значение и число в шаблоне. Остальные ( 500 000) занимаются наблюдением в ячейках таблицы:</p>
<p>[html]<br />
&lt;tr ng-repeat=&quot;prime in primes | orderBy:$index &quot;&gt;<br />
  &lt;td&gt;{{ &quot;index&quot; | lowercase }}&lt;/td&gt;<br />
  &lt;td&gt;{{ $index + 1 | number:0 | uppercase }}&lt;/td&gt;<br />
  &lt;td&gt;{{ &quot;prime number&quot; | lowercase }}&lt;/td&gt;<br />
  &lt;td&gt;{{ prime | number:0 | uppercase }}&lt;/td&gt;<br />
  &lt;td&gt;is prime? {{ prime | isPrime }}&lt;/td&gt;<br />
&lt;/tr&gt;<br />
[/html]</p>
<p>Обратим внимание, что для каждой строчки используются избыточные фильтры. Например:<code>{{ "index" | lowercase }}</code> &#8211; это статический текст, который никогда не меняется, но Ангуляр вычисляет его снова и снова, а результаты всегда одни и те же, даже когда количество строк меняется. Давайте удалим фильтры <code>lowercase</code>, <code>uppercase</code>, <code>isPrime</code> , которые по сути ничего не делают(можно обновиться до тега <a href="https://github.com/bahmutov/primes/releases/tag/step-5">step-5</a>):</p>
<p>[html]<br />
&lt;tr ng-repeat=&quot;prime in primes | orderBy:$index &quot;&gt;<br />
  &lt;td&gt;index&lt;/td&gt;<br />
  &lt;td&gt;{{ $index + 1 | number:0 }}&lt;/td&gt;<br />
  &lt;td&gt;prime number&lt;/td&gt;<br />
  &lt;td&gt;{{ prime | number:0 }}&lt;/td&gt;<br />
  &lt;td&gt;is prime? true&lt;/td&gt;<br />
&lt;/tr&gt;<br />
[/html]</p>
<p>Обновленное приложение содержит уже только 200 003 вотчеров, и соотвественно цикл дайджеста проходит в 2 раза быстрее.</p>
<h2 id="bind-once">Использование директивы bind-once</h2>
<p>Производительность уже серьезно была улучшена удалением ненужных фильтров, но мы можем ускорить еще. Отметим то, что в то время, как таблица не меняется, мы продолжаем вычислять 2 вотчера на каждую строчку, каждый раз, когда мы меняем значение поля ввода( что запускает цикл дайджеста). Данные не изменяются, поэтому мы не должны вычислять выражение еще раз. Angular1.3 <a href="https://docs.angularjs.org/guide/expression#one-time-binding">представляет</a> &#8220;одноразовое связывание&#8221; следующим синтаксисом <code>{{ ::prime}}</code>. Но AngularJS 1.2 &#8220;из коробки&#8221; такого увы не предоставляет. Как вариант можно использовать модуль <a href="https://github.com/Pasvaz/bindonce">bindonce</a>: изменения незначительны; фильтры также поддерживаются:</p>
<p>[html]<br />
&lt;tr ng-repeat=&quot;prime in primes | orderBy:$index &quot; bindonce&gt;<br />
  &lt;td&gt;index&lt;/td&gt;<br />
  &lt;td bo-text=&quot;$index + 1 | number:0&quot; /&gt;<br />
  &lt;td&gt;prime number&lt;/td&gt;<br />
  &lt;td bo-text=&quot;prime | number:0&quot; /&gt;<br />
  &lt;td&gt;is prime? true&lt;/td&gt;<br />
&lt;/tr&gt;<br />
[/html]</p>
<p>Обновленное приложение имеет только 3 вотчера (после отображения 100 000 простых чисел), и цикл дайджеста занимает в этом случае только 5мс. Ну что ж это уже похоже на отзывчивый интерфейс.</p>
<p>Обновить код можно по тегу <a href="https://github.com/bahmutov/primes/releases/tag/step-6">step-6</a>. И не забудьте поставить модуль <a href="https://github.com/Pasvaz/bindonce">bindonce</a>:</p>
<p>[shell]<br />
bower instal angular-bindonce<br />
[/shell]</p>
<p>&nbsp;</p>
<h2 id="get-rid-off-ng-repeat">Избавляемся от ng-repeat</h2>
<p>Как показало профилирование: генерация таблицы занимает 10 секунд, при этом каждая строчка и ячейка порождают несколько функциональных вызовов.</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2291" src="../../../wp-content/uploads/2015/02/each-row-linked.png" alt="each-row-linked" width="1111" height="729" /></p>
<p>Чтобы как-то улучшить эту часть, я написал свою функцию генерирования HTML и вывод его просто через <code>innerHTML</code>. То есть выкидываем <code>ng-repeat</code> вместе с содержимым (тег <a href="https://github.com/bahmutov/primes/releases/tag/step-7">step-7</a>):</p>
<p>[javascript]<br />
// use AngularJs built-in filter<br />
var number = $filter(&#8216;number&#8217;);<br />
function generateTableRows() {<br />
  var k;<br />
  var str = &#8221;;<br />
  for(k = 0; k &lt; $scope.n; k += 1) {<br />
    str += &#8216;&lt;tr&gt;&lt;td&gt;index&lt;/td&gt;&#8217;;<br />
    str += &#8216;&lt;td&gt;&#8217; + number(k + 1, 0) + &#8216;&lt;/td&gt;&#8217;;<br />
    str += &#8216;&lt;td&gt;prime number&lt;/td&gt;&#8217;;<br />
    str += &#8216;&lt;td&gt;&#8217; + number($scope.primes[k], 0) + &#8216;&lt;/td&gt;&#8217;;<br />
    str += &#8216;&lt;td&gt;is prime? true&lt;/td&gt;&lt;/tr&gt;&#8217;;<br />
  }<br />
  document.getElementsByTagName(&#8216;table&#8217;)[0].innerHTML = str;<br />
}<br />
$scope.find = function () {<br />
  // generate primes list as before<br />
  generateTableRows();<br />
}<br />
[/javascript]</p>
<p>Такое изменение дало увеличение производительности в 10 раз:</p>
<p><a href="../../../wp-content/uploads/2015/02/in-code-table-generation.png"><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2292" src="../../../wp-content/uploads/2015/02/in-code-table-generation.png" alt="in-code-table-generation" width="1110" height="475" /></a></p>
<p>Конечно же это лишает вас гибкости связывания представления с моделью, которую дает <code>ng-repeat</code> и так можно делать только тогда, когда вы точно уверенны, что данные меняться не будут.</p>
<p>&nbsp;</p>
<h2 id="initial-rendering">Ускоряем начальный рендеринг</h2>
<p>Давайте подойдем к проблеме с другой стороны: если процесс вычисления всех результатов занимает много времени, то мы можем показать только первоначальные результаты, и сделать это довольно быстро. То есть пользователь увидит какие-то результаты, в то время как остальные все еще будут рассчитываться. Мы можем вычислить и вывести первые 100 чисел очень быстро ( &lt; 30 мс). Я разбил логику на 2 шага и использовал $timeout сервис, чтобы выполнить второй шаг после того, как обновиться DOM и браузер отобразит эти первые 100 строк:</p>
<p>[javascript]<br />
$scope.find = function () {<br />
  // code as before<br />
  var firstBatchN = 100;<br />
  var k;<br />
  for (k = 0; k &lt; firstBatchN; k += 1) {<br />
    var prime = findPrime(k + 2);<br />
    $scope.primes.push(prime);<br />
  }<br />
  generateTableRows(0, firstBatchN);<br />
  // start second batch via event loop to let browser repaint<br />
  // return promise to allow timing this action<br />
  return $timeout(function computeSecondBatch() {<br />
    for (k = firstBatchN; k &lt; $scope.n; k += 1) {<br />
      var prime = findPrime(k + 2);<br />
      $scope.primes.push(prime);<br />
    }<br />
    generateTableRows(firstBatchN, $scope.n);<br />
  }, 0);<br />
};<br />
[/javascript]</p>
<p>Код доступен по тегу <a href="https://github.com/bahmutov/primes/releases/tag/step-8">step-8</a>.</p>
<p>На временном графике мы видим эти 2 шага довольно четко. Первая отрисовка заканчивается через 20мс после нажатия на кнопку find. Но пользователь не может ничего сделать с таблицей, так как вторая порция тормозит браузер пока вычисляются остальные числа и вычисляет отображение для всей таблицы:</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2293" src="../../../wp-content/uploads/2015/02/fast-first-batch.png" alt="fast-first-batch" width="2548" height="1212" /></p>
<p>&nbsp;</p>
<h2 id="in-to-pieces">Разбиваем &#8220;тяжелые&#8221; компоненты на небольшие части</h2>
<p>В ходе работы приложения для генерации и вывода чисел на экран браузер выполняет следующие операции:</p>
<ul>
<li>выполнение JavaScript</li>
<li>построение отображения (позиция или размер каждого DOM элемента)</li>
<li>отрисовка каждого компонента отдельно в буфер</li>
<li>отрисовка всех элементов из буфера</li>
</ul>
<p>Все действия совершаются в одном потоке, и это может представлять проблему производительности, когда одна из частей занимает много времени. Например: сложные CSS стили ведут к долгой отрисовке, блокировке клиентского кода. Каждая такая итерация(из 4 действий) должна занимать не больше чем 33мс, если мы хотим достичь <strong>30 fps</strong>, или меньше 16мс, если наша цель <strong>60 fps</strong>.</p>
<p>Предыдущем шаге мы разбили наше приложение на 2 части: первую выдачу и дальнейшую загрузку, которая уже серьезно тормозит браузер и не дает пользователю работать со страницей.</p>
<p>Давайте разобьем весь процесс на много маленьких частей, которые будут вычислять и отображать только 50 чисел. Полный цикл (выполнение кода, обновление DOM и рендеринг) не должен занять больше 30мс, не мешая пользователю взаимодействовать со страницей ( например: прокручивать вниз).</p>
<p>Чтобы запланировать выполнение кода после того как браузер отрисует предыдущую часть мы используем <code>$timeout</code> сервис:</p>
<p>[javascript]<br />
function computePrimes(first, last) {<br />
  var k;<br />
  for (k = first; k &lt; last; k += 1) {<br />
    var prime = findPrime(k + 2);<br />
    $scope.primes.push(prime);<br />
  }<br />
}<br />
function generateTableRows(first, last) {<br />
  // &#8230; тут мы генерируем HTML и сохраняем в str<br />
  document.getElementsByTagName(&#8216;tbody&#8217;)[0].innerHTML += str;<br />
  console.timeStamp(&#8216;updated tbody &#8216; + first + &#8216; to &#8216; + last);<br />
}<br />
function computeAndRenderBatch(first, last) {<br />
  computePrimes(first, last);<br />
  generateTableRows(first, last);<br />
  // возвращает промис, который разрешиться после отрисовки DOM<br />
  return $timeout(angular.noop, 0);<br />
}<br />
[/javascript]</p>
<p>Главный вычислительный метод <code>$scope.find</code> теперь создает большую цепочку промисов, которые будут выполнятся один за одним. И на каждом шаге будет вычислено 50 простых чисел,  сгенерирован HTML и добавлен в DOM:</p>
<p>[javascript]<br />
$scope.find = function () {<br />
  var batchSize = 50;<br />
  var k;<br />
  // начинаем с &quot;нулевого&quot; промиса (который сразу отрезолвится)<br />
  var computeAndLetUiRender = $q.when();<br />
  var computeNextBatch;<br />
  for (k = 0; k &lt; $scope.n; k += batchSize) {<br />
    computeNextBatch = angular.bind(null, computeAndRenderBatch,<br />
      k, Math.min(k + batchSize, $scope.n));<br />
    computeAndLetUiRender = computeAndLetUiRender.then(computeNextBatch);<br />
  }<br />
  // return promise to let timing code snippet know when we are done<br />
  return computeAndLetUiRender;<br />
};<br />
[/javascript]</p>
<p>Изменения кода доступны в теге <a href="https://github.com/bahmutov/primes/releases/tag/step-9">step-9</a>.</p>
<p>Посмотрим на результаты профилирования:</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2296" src="../../../wp-content/uploads/2015/02/small-batches-profile.png" alt="small-batches-profile" width="2218" height="912" /></p>
<p>Мы можем посмотреть на каждую порцию временного графика в отдельности, чтобы убедиться что наши действия выполняются одно за одним.</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2297" src="../../../wp-content/uploads/2015/02/after-dom-update-using-timeout.png" alt="after-dom-update-using-timeout" width="1550" height="666" /></p>
<p>Но мы также можем заметить, что обновления постепенно замедляются. Фиолетовый столбик(отрисовка) становится все больше и больше с каждым разом.</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2298" src="../../../wp-content/uploads/2015/02/small-batches-timeline.png" alt="small-batches-timeline" width="950" height="284" /></p>
<p>Проблема в способе добавления новых строк в таблицу: каждый раз при добавлении браузеру приходиться перерисовывать всю таблицу!</p>
<p>[javascript]<br />
function generateTableRows(first, last) {<br />
  // generate new rows HTML markup into variable str<br />
  document.getElementsByTagName(&#8216;tbody&#8217;)[0].innerHTML += str;<br />
}<br />
[/javascript]</p>
<p>Вместо замены всего содержимого таблицы мы можем создавать новую таблицу и просто добавлять ее в структуру документа ( <em>Мы так же можем добавлять другой элемент tbody в ту же самую таблицу. Но этот вариант не оценивался</em> )</p>
<p>[javascript]<br />
function generateTableRows(first, last) {<br />
  var k, txt = angular.bind(document, document.createTextNode);<br />
  var table = document.createElement(&#8216;table&#8217;);<br />
  for(k = first; k &lt; last; k += 1) {<br />
    var row = table.insertRow();<br />
    row.insertCell().appendChild(txt(&#8216;index&#8217;));<br />
    row.insertCell().appendChild(txt(k + 1));<br />
    row.insertCell().appendChild(txt(&#8216;prime number&#8217;));<br />
    row.insertCell().appendChild(txt($scope.primes[k]));<br />
    row.insertCell().appendChild(txt(&#8216;is prime? true&#8217;));<br />
  }<br />
  // schedule DOM update by attaching new table element to the body<br />
  document.body.appendChild(table);<br />
}<br />
[/javascript]</p>
<p>Обновленния берем в теге <a href="https://github.com/bahmutov/primes/releases/tag/step-10">step-10</a>.</p>
<p>Ну вот мы и добились 30fps. Что означает, что мы можем прокручивать и смотреть результаты относительно без тормозов, в то время как браузер продолжает вычислять оставшиеся результаты.</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2299" src="../../../wp-content/uploads/2015/02/appending-separate-tables.png" alt="appending-separate-tables" width="2794" height="652" /></p>
<p>&nbsp;</p>
<h2 id="web-workers">Перекладываем вычисления на WebWorkers</h2>
<p>В итоге, я решил вынести вычисление простых чисел в поток вебворкеров, чтобы выполнять параллельно с основным кодом.  Перемещаем <code>isPrime</code> и <code>findPrime</code> методы в файл <code>primes.js</code>. Они будут общаться с основным кодом по средством сообщений:</p>
<p>[javascript]<br />
// primes.js<br />
onmessage = function (e) {<br />
  var first = e.data.first;<br />
  var last = e.data.last;<br />
  var k, primes = [];<br />
  for (k = first; k &lt; last; k += 1) {<br />
    var prime = findPrime(k + 2);<br />
    primes.push(prime);<br />
  }<br />
  // посылаем результаты обратно<br />
  postMessage(primes);<br />
};<br />
[/javascript]</p>
<p>Чтобы упростить взаимодействие с вебворкерами, я создал сервис:</p>
<p>[javascript]<br />
angular.module(&#8216;Primes&#8217;, [])<br />
  .factory(&#8216;PrimeWorker&#8217;, function ($q) {<br />
    var worker = new Worker(&#8216;./primes.js&#8217;);<br />
    var defer;<br />
    worker.onmessage = function(e) {<br />
      defer.resolve(e.data);<br />
    };<br />
    return {<br />
      computePrimes: function (first, last) {<br />
        defer = $q.defer();<br />
        worker.postMessage({<br />
          first: first,<br />
          last: last<br />
        });<br />
        return defer.promise;<br />
      }<br />
    }<br />
  });<br />
[/javascript]</p>
<p>Метод <code>$scope.find </code>должен обрабатывать вычисления асинхронно, поэтому</p>
<p>[javascript]<br />
.controller(&#8216;primesController&#8217;, function ($scope, $filter, $timeout, $q, PrimeWorker) {<br />
  function computePrimes(first, last) {<br />
    return PrimeWorker.computePrimes(first, last).then(function (numbers) {<br />
      // копируем результаты в массив<br />
      var k, n = numbers.length;<br />
      for(k = 0; k &lt; n; k += 1) {<br />
        $scope.primes.push(numbers[k]);<br />
      }<br />
    });<br />
  }<br />
  function computeAndRenderBatch(first, last) {<br />
    // результатом будет промис<br />
    return computePrimes(first, last).then(function () {<br />
      generateTableRows(first, last);<br />
      return $timeout(angular.noop, 0);<br />
    });<br />
  }<br />
[/javascript]</p>
<p>Код доступен по тегу <a href="https://github.com/bahmutov/primes/releases/tag/step-11">step-11</a>.</p>
<p>!Внимание: Для загрузки вебворкеров нам понадобится локально запустить веб-сервер. Могу порекомендовать <a href="https://github.com/nodeapps/http-server">http-server</a>. Устанавливает и запускается очень просто(команды выполняем из директории проекта):</p>
<p>[shell]<br />
$ npm install http-server -g<br />
$ http-server<br />
[/shell]</p>
<p>Профилирования процессора теперь показывает приятные узкие столбики для основного кода:</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2300" src="../../../wp-content/uploads/2015/02/web-worker-cpu-profile.png" alt="web-worker-cpu-profile" width="2794" height="724" /></p>
<p>Временной график показывает, что все выполняется быстрее и почти все итерации попадают под <strong>60fps</strong>:</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2301" src="../../../wp-content/uploads/2015/02/web-worker-timeline.png" alt="web-worker-timeline" width="2794" height="668" /></p>
<h2></h2>
<h2 id="memory-allocation-optimization">Оптимизация процесса выделения памяти</h2>
<p>Если наше приложение в процессе выполнения занимает и освобождает много памяти, то браузер должен переодически останавливаться, чтобы собрать освободившуюся память. Задержки при сборке мусора непредсказуемы и могут быть долгими. Чтобы найти этим события(сборка мусора) на временном графике включите фильтр и введите &#8220;<em>gc</em>&#8221; (garbage collection). В нашем случае мы видим серьезные задержки по сборке мусора: несколько мегабайт освобождаются каждый раз и это занимает более чем 100мс. (Для теста я генерировал 150 000 простых чисел порциями по 10 000). Это заметно не вооруженным взглядом, если вы включите график работы с памятью (галочка &#8220;Memory&#8221;):</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2303" src="../../../wp-content/uploads/2015/02/memory-dynamically-allocated.png" alt="memory-dynamically-allocated" width="2798" height="888" /></p>
<p>Первый кандидат на освобождение памяти &#8211; массив <code>$scope.primes</code>. Отметим, что он растет динамически, потому что он начинается с размерности 0 и мы продолжаем добавлять новые простые числа в массив одно за одним:</p>
<p>[javascript]<br />
var k, n = numbers.length;<br />
for(k = 0; k &lt; n; k += 1) {<br />
  $scope.primes.push(numbers[k]);<br />
}<br />
[/javascript]</p>
<p>Это очень не эффективно с точки зрения выделения памяти: когда новый элемент добавляется в непустой массив, среда выполнения выделяет память под новый массив (обычно выделяется в 2 раза больше памяти), скопировать числа и почистить память за исходным. Я изменил код задав массив необходимой длинны с самого начала (используя заданное количество простых чисел):</p>
<p>[javascript]<br />
$scope.primes = new Array($scope.n);<br />
$scope.computedN = 0;<br />
// copy numbers<br />
var k, n = numbers.length;<br />
for(k = 0; k &lt; n; k += 1) {<br />
  $scope.primes[$scope.computedN] = numbers[k];<br />
  $scope.computedN += 1;<br />
}<br />
[/javascript]</p>
<p>Обновляемся из тега <a href="https://github.com/bahmutov/primes/releases/tag/step-12">step-12</a>.</p>
<p>Теперь временной график показывает не такие серьезные скачки в памяти:</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2304" src="../../../wp-content/uploads/2015/02/memory-preallocated.png" alt="memory-preallocated" width="2796" height="890" /></p>
<p>Примечание: иногда профайлер барахлит и нужно закрыть все и открыть заново.</p>
<p>&nbsp;</p>
<h2 id="memory-profile-isolation">Изоляция профиля памяти</h2>
<p>Чтобы лучше увидеть выделение памяти давайте изолируем конкретные шаги. Для начала давайте выключим генерацию DOM &#8211; она создает много &#8220;шума&#8221; на графике при размещении элементов.</p>
<p>[javascript]<br />
function computeAndRenderBatch(first, last) {<br />
  return computePrimes(first, last).then(function () {<br />
    // generateTableRows(first, last);<br />
    return $timeout(angular.noop, 0);<br />
  });<br />
}<br />
[/javascript]</p>
<p>Теперь мы можем запустить профайлер выделяемой памяти, а не профайлер процессора. Включаем профайлер и затем нажимаем кнопку &#8220;Find&#8221;:</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2305" src="../../../wp-content/uploads/2015/02/profile-heap-allocations.png" alt="profile-heap-allocations" width="2018" height="744" /></p>
<p>После чего мы можем увидеть выделение памяти под большие массивы с начала. (прим.:<em> можем навести мышкой, чтобы увидеть конкретные значения</em>). Также можно отметить что общий размер памяти 600 008 байт (при генерации 150 000 простых чисел). Движок V8 обнаружил что мы добавляем только целые числа в массив, поэтому используется только 4 байта на элемент. Массив также имеет свойство <code>length</code> &#8211; эти дополнительные 8 байт.</p>
<p><img decoding="async" loading="lazy" class="alignnone  wp-image-2306" src="../../../wp-content/uploads/2015/02/primes-array.png" alt="primes-array" width="648" height="242" /></p>
<p>Этот профиль дает нам представление о выделении памяти из основного кода, но он не показывает выделение памяти в вебворкерах. Изучить утечки памяти в вебворкерах выберите &#8220;primes.js&#8221; перед стартом профилирования памяти</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2307" src="../../../wp-content/uploads/2015/02/profile-web-worker-heap.png" alt="profile-web-worker-heap" width="2018" height="732" /></p>
<p>Собраный профиль веделения памяти на вебворкерах менее детален из-за браузерных ограничений. Но мы все равно можем четко увидеть растущее выделение памяти. Если посмотрим детально &#8211; обнаружим массив <code>foundPrimes</code>:</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2308" src="../../../wp-content/uploads/2015/02/inspect-web-worker-heap.png" alt="inspect-web-worker-heap" width="2798" height="874" /></p>
<p>Для массива <code>foundPrimes</code> мы так же можем сразу выделить необходимое количество памяти (тем самым предотвращая постоянное изменение размера и сборку мусора).</p>
<h2 id="on-request-compulation">Вычисление только по запросу</h2>
<p>Давайте изменим способ генерации данных приложением. Вместо предвычислений тысяч простых чисел, сгенерируем небольшую часть чисел и отрисуем таблицу. Если пользователь прокрутит до конца таблицы в поисках большего количества чисел, мы сгенерируем новую партию чисел и добавим их в DOM. Можно легко привязать генерацию к прокрутке используя директиву <a href="http://binarymuse.github.io/ngInfiniteScroll/index.html">ngInfiniteScroll</a>. Для этой директивы нам понадобится также подключить jQuery:</p>
<p>[html]<br />
&lt;script src=&quot;bower_components/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt;<br />
&lt;script src=&quot;bower_components/angular/angular.js&quot;&gt;&lt;/script&gt;<br />
&lt;script src=&quot;bower_components/ngInfiniteScroll/build/ng-infinite-scroll.min.js&quot;&gt;&lt;/script&gt;<br />
[/html]</p>
<p>Для простоты я снова использую <code>ng-repeat</code>. Мы запустим <code>$scope.find</code> метод тогда, когда границы таблицы сравняются с границами окна пользователя. Первый вызов <code>$scope.find</code> сделаем вручную с помощью атрибута <code>infinite-scroll-immediate-check</code>.</p>
<p>[html]<br />
&lt;table id=&quot;table&quot; width=&quot;500&quot;&gt;<br />
  &lt;tbody infinite-scroll=&quot;find()&quot;<br />
    infinite-scroll-distance=&quot;3&quot;<br />
    infinite-scroll-immediate-check=&quot;true&quot;<br />
    infinite-scroll-disabled=&quot;computing&quot;&gt;<br />
    &lt;tr ng-repeat=&quot;prime in primes&quot;&gt;<br />
      &lt;td&gt;index&lt;/td&gt;<br />
      &lt;td&gt;{{ $index + 1 | number:0 }}&lt;/td&gt;<br />
      &lt;td&gt;prime number&lt;/td&gt;<br />
      &lt;td&gt;{{ prime | number:0 }}&lt;/td&gt;<br />
      &lt;td&gt;is prime? true&lt;/td&gt;<br />
    &lt;/tr&gt;<br />
  &lt;/tbody&gt;<br />
&lt;/table&gt;<br />
[/html]</p>
<p>Я выкинул ручную генерацию html таблицы, оставил только вычисление числа (которое по прежнему в вебворкере).</p>
<p>[javascript]<br />
$scope.find = function () {<br />
  $scope.computing = true;<br />
  return computePrimes($scope.primes.length, $scope.primes.length + batchSize)<br />
  .then(function () {<br />
    console.log(&#8216;computed&#8217;, $scope.primes.length, &#8216;primes&#8217;);<br />
    $scope.computing = false;<br />
  });<br />
};<br />
[/javascript]</p>
<p>Обновляем код в теге <a href="https://github.com/bahmutov/primes/releases/tag/step-13">step-13</a>.</p>
<p>Теперь страница показывает только первые 100 чисел. Если вы начнете прокручивать вниз, то новые будут вычислены новые числа  и добавлены к таблице. Генерация довольно быстрая, чтобы не тормозить прокрутку. На временном графике мы можем увидеть 3 столбика для генерации первых 400 чисел (первые 100 сгенерированны до профилирования):</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2311" src="../../../wp-content/uploads/2015/02/infinite-scroll.png" alt="infinite-scroll" width="1530" height="1254" /></p>
<h2></h2>
<h2 id="watched-objects-minimization">Минимизация наблюдаемых объектов</h2>
<p>Еще одна не очевидная причина тормозов в AngularJS &#8211; тяжелые вотчеры, а именно вотчеры, которые наблюдают за сложным объектом, а еще хуже за результатом функции, которая возвращает такой объект. Вот эти 2 вотчера:</p>
<p>[javascript]<br />
angular.module(&#8216;Primes&#8217;, [])<br />
  .controller(&#8216;primesController&#8217;, function ($scope) {<br />
    $scope.primes = &#8230;<br />
    $scope.$watch(&#8216;primes&#8217;, &#8230;);<br />
    // OR<br />
    $scope.$watch(function () {<br />
      return $scope.primes;<br />
    }, &#8230;);</p>
<p>[/javascript]</p>
<p>AngularJS делает грязную проверку &#8211; в ходе каждого цикла дайджеста каждая наблюдаемая функция вычисляется и возвращает значение, которое сравнивается с предыдущим возвращенным значением. Это означает, что последнее значение было сохранено. Если вы используете вотчер с <a title="для объектов это полное сравнение вложенных значений, а не только ссылки на объект" href="#">глубоким сравнением</a>, тогда ангуляр сохраняет полную копию возвращаемого объекта. Это может быть довольно дорого с точки зрения производительности. Например массив с объектами:</p>
<p>[javascript]<br />
$scope.n = 10000;<br />
$scope.primes = new Array($scope.n);<br />
for (k = 0; k &lt; $scope.n; k += 1) {<br />
  $scope.primes[k] = { foo: { bar: &#8216;baz&#8217; } };<br />
}<br />
$scope.$watch(function primesWatcher() {<br />
  return $scope.primes;<br />
}, angular.noop, true); // do nothing on value change<br />
[/javascript]</p>
<p>Взять код можно из тега <a href="https://github.com/bahmutov/primes/releases/tag/step-14">step-14</a>.</p>
<p>Изначально загрузка приложения задерживатся на 500мс из-за объекта возвращаемого из <code>primesWatcher</code> и копируемого для дальнейшего сравнения. Приложение понесет тоже наказание каждый раз, когда объект primes будет изменен.</p>
<p><img decoding="async" loading="lazy" class="alignnone size-full wp-image-2312" src="../../../wp-content/uploads/2015/02/deep-copy-profile.png" alt="deep-copy-profile" width="2370" height="960" /></p>
<p>Важная заметка: <span style="text-decoration: underline;">полная копия занимает НАМНОГО больше времени, чем полное сравнение</span>. Отсюда и задержка, которая появляется не в момент прохода дайджеста, а только когда что-то изменено. На практике это означает медленную реакцию на ввод пользовательских данных, когда результат вотчера копируется.</p>
<p>Несколько предложений как победить дорогостоящее полное копирование в вотчерах:</p>
<ul>
<li>стараться использовать сравнение по ссылке (но не полный перебор)</li>
<li>повторно использовать один и тот же  вотчер для нескольких действий</li>
</ul>
<p>Например:</p>
<p>[javascript]<br />
// вместо нескольких вотчеров<br />
$scope.$watch(function () {<br />
  return $scope.primes;<br />
}, foo, true);<br />
$scope.$watch(function () {<br />
  return $scope.primes;<br />
}, bar, true);<br />
$scope.$watch(function () {<br />
  return $scope.primes;<br />
}, baz, true);<br />
// используем один<br />
$scope.$watch(function () {<br />
  return $scope.primes;<br />
}, function () {<br />
  foo();<br />
  bar();<br />
  baz();<br />
}, true);<br />
[/javascript]</p>
<ul>
<li> использовать свою логику определения изменения состояния</li>
</ul>
<p>Объект <code>primes</code> изменяется каждый раз, когда мы добавляем новое число:</p>
<p>[javascript]<br />
.controller(&#8216;primesController&#8217;, function ($scope) {<br />
  var primesChanged = 0;<br />
  $scope.find = function () {<br />
    $scopes.primes.push(findNextPrime());<br />
    primesChanged += 1;<br />
  };<br />
  $scope.$watch(function () {<br />
    return primesChanged;<br />
  }, function () { &#8230; });<br />
});<br />
[/javascript]</p>
<p>Тут я использую счетчик, чтобы гарантировано запускать вотчер, когда значение изменяется. Если бы я просто возвращал true/false, цикл дайджеста бы не заметил разницы, так как только разница возвращаемых значений играет роль, а не сами значения возвращаемые функцией.</p>
<h2></h2>
<h2 id="conclusions">Выводы и дальнейшее исследование</h2>
<p>Улучшение производительности любого приложения это пошаговый процесс.</p>
<ol>
<li>Профилируйте, чтобы найти проблемные места</li>
<li>Удаляется проблемные места</li>
<li>Повторяйте шаги 1-2</li>
</ol>
<p>Я считаю целесообразным сначала удалить самые явные проблемные места, прежде чем погружаться в полный анализ. Во-первых, мы удаляем код, который дает основные тормоза. Во-вторых, удаление этого кода могло повлиять на другие проблемные места.</p>
<p>Как правило код любого JavaScript приложения имеет проблемные места. Как только клиентский код оптимизирован, я переключаюсь на профилирование и оптимизацию Ангуляра, по большей части это удаление лишней работы, которую делает фреймворк. После чего, я переключаю внимание на выполнение кода/браузерную отрисовку, в надежде разбить большие куски на сравнительно небольшие части.</p>
<p>Граматное решение по улучшению производительности требует знаний JavaScript, оптимизаторов среды выполнения, процесса браузерного рендеринга и специфики фреймворка вашего приложения. В первую очередь оно требует сравнение производительности приложения с ожиданиями пользователя интерфейса при различных сценариях. AngularJS имеет некоторые проблематичные места, такие как грязная проверка в ходе цикла дайджеста. Однако, это очень гибкий фреймворк, как вы могли убедиться на примерах. Я смог изменить части системы, заменить шаги, но это по прежнему Ангулар приложение. То есть мы можем улучшить производительность каких-то конкретных частей без жертвы гибкости и простоты для всего приложения.</p>
<p><strong>UPD</strong>: как альтернативу ng-repeat c ngInfiniteScroll можно использовать директиву <a title="http://kamilkp.github.io/angular-vs-repeat" href="http://kamilkp.github.io/angular-vs-repeat">angular-vs-repeat</a> (обрабатывать только &#8220;видимые&#8221; строчки), которая так же дает хороший прирост к производительности.</p>
			</div><!-- .entry-content -->

	<footer class="entry-meta">
		This entry was posted in <a href="../../../category/%d1%85%d0%be%d1%87%d1%83-%d1%81%d0%b4%d0%b5%d0%bb%d0%b0%d1%82%d1%8c-%d0%bc%d0%b8%d1%80-%d0%bb%d1%83%d1%87%d1%88%d0%b5/index.html" rel="category tag">Хочу сделать мир лучше</a> and tagged <a href="../../../tag/angularjs/index.html" rel="tag">AngularJs</a>, <a href="../../../tag/chrome/index.html" rel="tag">chrome</a>, <a href="../../../tag/javascript/index.html" rel="tag">javascript</a>, <a href="../../../tag/performance/index.html" rel="tag">performance</a>, <a href="../../../tag/snippet/index.html" rel="tag">snippet</a>, <a href="../../../tag/%d0%be%d0%bf%d1%82%d0%b8%d0%bc%d0%b8%d0%b7%d0%b0%d1%86%d0%b8%d1%8f/index.html" rel="tag">оптимизация</a> by <a href="../../../author/admin/index.html">Stepan</a>. Bookmark the <a href="index.html" title="Permalink to Оптимизируем AngularJS. Подробный разбор." rel="bookmark">permalink</a>.
		
			</footer><!-- .entry-meta -->
</article><!-- #post-2063 -->

					
<div id="disqus_thread"></div>

				
			</div><!-- #content -->
		</div><!-- #primary -->


	</div><!-- #main -->

	<footer id="colophon">

			

			<div id="site-generator">
												<a href="https://wordpress.org/" class="imprint" title="Semantic Personal Publishing Platform">
					Proudly powered by WordPress				</a>
			</div>
	</footer><!-- #colophon -->
</div><!-- #page -->

<script type='text/javascript' src='../../../wp-includes/js/comment-reply.min9b30.js?ver=6.3.1' id='comment-reply-js'></script>
<script type='text/javascript' id='disqus_count-js-extra'>
/* <![CDATA[ */
var countVars = {"disqusShortname":"stepansuvorovblog"};
/* ]]> */
</script>
<script type='text/javascript' src='../../../wp-content/plugins/disqus-comment-system/public/js/comment_count7ee6.js?ver=3.0.23' id='disqus_count-js'></script>
<script type='text/javascript' id='disqus_embed-js-extra'>
/* <![CDATA[ */
var embedVars = {"disqusConfig":{"integration":"wordpress 3.0.23"},"disqusIdentifier":"2063 http:\/\/stepansuvorov.com\/blog\/?p=2063","disqusShortname":"stepansuvorovblog","disqusTitle":"\u041e\u043f\u0442\u0438\u043c\u0438\u0437\u0438\u0440\u0443\u0435\u043c AngularJS. \u041f\u043e\u0434\u0440\u043e\u0431\u043d\u044b\u0439 \u0440\u0430\u0437\u0431\u043e\u0440.","disqusUrl":"https:\/\/stepansuvorov.com\/blog\/2015\/02\/angularjs-optimization\/","postId":"2063"};
/* ]]> */
</script>
<script type='text/javascript' src='../../../wp-content/plugins/disqus-comment-system/public/js/comment_embed7ee6.js?ver=3.0.23' id='disqus_embed-js'></script>

</body>

<!-- Mirrored from stepansuvorov.com/blog/2015/02/angularjs-optimization/ by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 11 Feb 2025 13:37:13 GMT -->
</html>
